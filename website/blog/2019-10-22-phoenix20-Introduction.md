---
title: phoenix2.0 入门必看
author: wenchang.lan
authorImageURL: https://gitlab.iquantex.com/uploads/-/system/user/avatar/2/avatar.png
---
phoenix 架构设计上选择了 DDD/CQRS/ES，那么对标 SpringCloud + 数据库方案，我们获得了什么，又面临了哪些挑战

优势：

*   高性能和可扩展性
    *   速度快，业务逻辑面向内存，无论业务多复杂，都仅有一次持久化 IO 操作
    *   避免资源竞争，单聚合根的消息进行排队单线程处理
    *   采用分布式，支持动态伸缩，所有聚合根分布在不同节点上进行并行计算
    *   服务易扩展，服务基于消息队列扩展，服务间松耦合
*   透明性和可审计性
    *   基于事件的系统透明度高，一切皆可见
    *   可审计且方便恢复和重现历史，安全性大大提高
*   业务敏捷性
    *   事件驱动微服务设计，且通过协调者调用各个服务，服务间完全松耦合
    *   面向内存的简单无依赖的编程模式对业务的变化，提供了快速相应能力
*   开发易用性
    *   读写模型可以分别设计，互不影响，独立优化
    *   面向对象编程，免去了各种 SQL，各种中间件技术，聚焦业务逻辑
    *   单线程，免去多线程下的各种复杂技术问题（死锁、互斥、不确定行为等）
    *   对单元测试很友好

<!--truncate-->

挑战：

*   要求架构师、需求分析师能对业务进行全面分析，进行领域建模
*   系统升级迭代需要做好兼容，对开发人员要求高
*   转变思维

*   Cmd(Command 命令）：  表示请求入参
*   Event（事件）：领域内聚合根产生的事件，表示已发生的事实
*   DDD（Domain Design Driver 领域驱动设计）： 一门软件设计理论
*   Aggregate（聚合根）：DDD 理论中的概念，聚合定义了一组具有内聚关系的相关对象集合，每个聚合都有一个根对象，聚合内的对象只能通过聚合根进行操作。
*   CQRS(Command Query Responsibility Segregation 命令查询职责分离）： 读写分离的架构思想
*   C 端（Command Side 写端）： 负责命令处理（写请求） 
*   Q 端（Query Side 读端）:  负责查询处理（读请求）
*   ES（EventSourcing 事件溯源）： 通过 EventSoucing 恢复聚合根的最新状态
*   EventStore（事件存储）：存储事件，用于 EventSoucing 恢复聚合根最新状态

聚合根
---

*   聚合定义了一组具有内聚关系的对象集合，每个聚合拥有一个聚合根，聚合内所有对象的修改都必须经过聚合根来操作。
*   单个聚合根处理采用单线程，保证单个聚合根修改的原子性和强一致性（无锁）
*   聚合根之间可以采用并发处理，提升系统并行能力

In-Memory
---------

*   In-Memory 含义是：整个系统中所有的聚合根对象都活在内存，而不是用到才从 DB 读取，进行逻辑处理后，再更新数据库。
*   服务接收到 Cmd，调用业务逻辑处理，业务处理时定位到内存中的聚合根对象，聚合根处理命令产生事件，发布事件。

EventSourcing
-------------

*   不保存聚合根的最新状态， 而是保存聚合根产生的所有事件，通过 EventSourcing 得到聚合根的最新状态（类比数据库的 redolog）
*   一个命令产生后，有且只有一个聚合根可以处理该命令，经过路由定位找到该聚合根后，聚合根处理命令会产生一个事件后， 先持久化事件，再修改聚合根内存状态。
*   当服务发生故障或重启，这个时候命令无法找到聚合根进行处理（内存数据已丢失）， 就会通过事件溯源，从持久化中读出聚合根的所有事件，并按原来产生的顺序，重新调用聚合根处理，恢复聚合根最新的状态。

CQRS
----

CQRS 是一种读写分离的架构思想， 存在多种实现：

1.  最常见的是基于数据库读写分离
2.  数据底层存储不分离，但是逻辑上代码分离
3.  数据底层存储分离，C 端采用 EventSourcing 技术，EventStore 存储事件；Q 端订阅事件，存储状态数据到 DB，提供查询功能（本设计采用方式）

常见的 CQRS/ES 架构  
![](https://portal.iquantex.com/confluence/download/attachments/39747647/image2019-11-19_21-6-47.png?version=1&modificationDate=1574168808000&api=v2)  
CQRS 适用场景：

*   业务接受最终一致性模型
*   应用的写模型和读模型差别非常大
*   应用有高并发写和高并发读的性能要求
*   适合需求固定明确的场景（稳定的领域模型）

CQRS 高性能原理：

*   有效减少网络 IO：In-Memory， 只存在一次事件存储 IO
*   避免资源竞争：单线程处理单个聚合跟（无锁）
*   读写分离：读写端完全独立，互不影响