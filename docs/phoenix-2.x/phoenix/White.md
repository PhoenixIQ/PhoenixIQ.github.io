---
id: phoenix-white-page-2x
title: Phoenix 白皮书
---

## 背景
随着中国社会财富的迅速膨胀和资管新规的推出，资产管理行业出现了新的发展趋势。首先是一系列监管规则推出，推动资产管理回归本源，对于资产管理人的资产主动管理能力提升产生了强烈诉求。再者，客户特别是机构客户的认知和能力的提升，倒逼资产管理机构要提供更加专业的服务能力。第三，市场越来越充分的竞争，使得所有的资产管理机构都要往精细化管理方向转型。最后，以专户管理为标志的客户个性化、专业化服务的诉求使得管理人也面临创新压力。这些发展趋势，使得整个行业对新型的、高效的、更智能的资产管理系统平台的需求变得越来越迫切。

众所周知，资管系统所承载的业务复杂度极高，涉及到的模块广：组合、交易、头寸、风控、估值、归因、风险等等，覆盖的业务种类多：固收、权益、期货、衍生品、非标等等。这样的业务复杂性，需要系统做到模块化及模块间松耦合，保障模块彼此间不会有“腐败传导”，并且可进行独立升级、优化，通过重新排定组件来应对业务流程的快速改变需求。

当前的资管业务的发展趋势是往数量化、模型驱动型投资管理模式方向发展，要求业务系统在保持很好的操作型能力的同时，还要进行大量的分析计算，这就要求资管系统逐步转型为以分析管理型能力为主的系统。而且，交互型系统需要更加好地符合业务快速响应的能力，强调用户体验和交互的逻辑性，部署和迭代更新足够快，要求这类型系统能够尽可能多地围绕客户体验和场景来打造。
以上这些资管行业的发展与新一代资管系统的发展特点，都要求配套的技术体系建设从设计思想、架构设计、实现技术等方面都要有新的突破，尤其是系统架构和底层基础平台方面，需要做重新的设计。

目前，行业普遍使用基于数据库和存储过程等技术来开发资管系统，支持业务的发展。这些系统其特点是偏操作型，注重流程的处理，所采用的单体化架构，技术相对老旧，功能模块采用紧耦合，导致其开发模式很重，变更交付周期长，无法适应现代资管行业的各种业务创新多、客户需求响应快、分析计算量大等需求，后期架构虽然有所优化，但是没有发生根本性的变化，依然存在有一些缺点，比如在扩展性、可用性、性能瓶颈的解决方案上，都有明显的弱点。
所以，以新架构、新技术、新模式打造新一代资管系统，变得极其迫切。同时，行业机构都开始大力发展金融科技能力，自主研发成为IT战略的核心建设内容之一。如何利用成熟技术解决自主研发能力和有限资源的问题，也是一个亟待解决的新课题。

## 概述
Phoenix是宽拓自主研发的一款消息驱动型的高性能Java开发框架，专注于降低金融行业中业务复杂性高、性能要求高的应用系统的开发难度，助力研发团队打造专业、高效的微服务化的金融应用系统。Phoenix框架封装了复杂的底层技术，提供强大的内存保护机制，为应用提供极高的稳定性、基于内存的高性能的计算能力和动态伸缩扩展的能力，匹配当前和未来金融领域海量数据实时分析的强烈算力需求。同时，针对行业技术架构往微服务迁移的发展趋势和微服务架构使用的核心挑战，Phoenix提供了分布式事务处理引擎，满足金融领域微服务应用间的业务完整性、数据一致性的要求。除此之外，Phoenix还提供了强大的实时监控和在线管理功能，为系统高效智能运维提供了基础。搭配DevOps工具，提升了研发的持续集成和交付能力。


## 架构设计
Phoenix是一套（准）微服务开发框架。在应用系统架构方面，提供了包括客户端开发、服务端开发、消息通讯架构、服务端状态数据存储和恢复、计算层和消息层监控、服务端运维等架构方案。而在业务开发方面，Phoenix提供了一套领域驱动设计模式(DDD)的实现模型，业务开发中的领域模型定义以聚合根(Aggregate Root)的形式作为业务计算的基本单元，在整个业务计算的流程中，聚合根对象之间仅以消息(Message)作为数据交互接口。框架对聚合根对象的状态管理和多层次交互的实现进行了封装。

### 整体架构
TODO 整体架构图


### 技术架构
TODO 技术架构图


## 框架特性
基于Phoenix框架开发的业务应用系统不管在业务建模和系统架构上都有别于传统的应用服务系统，同时也跟其他微服务开发框架有所区别。Phoenix框架致力于为复杂业务场景、可靠性要求高、性能要求高和服务模块高度解耦的应用系统提供强大的开发和运维能力。所以，Phoenix框架提供了以下应用架构特性。

### 内存计算
TODO 配图
在传统的业务系统中，为了对业务数据进行存储和管理，企业应用系统一般选择使用数据库等存储服务来实现。业务模型往往与数据模型有着紧密的耦合，如此一来，随着业务模型变得复杂，为了满足这些复杂的业务需求实现，对应的数据模型和算法也开始变得越来越复杂，从而带来严重的性能问题。尽管我们有许多手段在数据库系统中实现并维护这些数据模型和算法，但这对数据建模和算法实现等开发都是个巨大的挑战，同时大量的IO可能使得各种优化手段都无济于事。

如果业务数据的修改完全在内存中进行，得益于内存极高的速度，将复杂的数据模型和算法实现搬到内存中，业务计算的速度也能得到极大提升。此外，业务数据模型和算法面向内存构建，将复杂的数据模型和算法过程与数据库系统解耦开来，简化计算层和存储层的交互，也能减少IO次数，为性能带来提升。

但内存计算技术也带来的其他方面的问题。第一是内存数据在进程结束后无法进行保存，框架需要提供额外的手段，保证服务在遇到故障时，内存中的业务数据能可靠地进行恢复。第二是，相比将数据模型放到数据库等成熟的存储中，将数据完全运行内存中不能方便的提供数据查询能力。所以，针对以上两个问题，Phoenix都提供了解决方案。EventStore领域事件存储解决了内存数据的可靠恢复问题。聚合根对象在处理消息时产生领域事件，领域事件是聚合根对象状态变化的依据，聚合根对象在更新状态前会将领域事件保存到EventStore中。这样，如果聚合根对象所处的服务节点出现故障时，通过从EventStore中读取领域事件，可以在节点重启后重新构建该聚合根对象的状态，或者通过集群的能力，在其他节点恢复聚合根状态，这种通过领域事件恢复状态的技术称为EventSourcing。

### 微服务
应用系统的微服务化是当下的趋势，微服务化的应用系统拥有组件化、松耦合、自治等优势。Phoenix框架对开发微服务化的应用系统提供了支持，根据领域划分构建模块化的服务，可以对服务进行独立的开发、测试和部署。服务间通讯使用消息队列，使得应用系统可以进行灵活的模块配置和功能扩展。

### 消息驱动
TODO 配图

应用系统中不同服务之间的数据交互有同步和异步两种方式，服务间同步调用会使得服务之间相互耦合，同步调用也可能会给服务间带来大量的等待和阻塞，影响系统性能。而在基于消息驱动的架构中，服务间的交互通过响应异步消息的方式进行，服务需要接入系统时，仅需要该服务监听并响应相关的消息，基于这样的方式，我们可以构建高度解耦的应用系统。

消息驱动架构中服务基于Fire-and-Forget原则，各服务仅需处理其领域接收到的消息，没有同步调用带来的等待和阻塞，系统的整体性能得以提高。

### 线性伸缩
高并发场景对应用系统的处理能力是个严峻的挑战。在提高系统的并发处理能力上，Phoenix框架使用Actor模型以聚合根对象为调度单位进行线程调度，以提升单节点部署的情况下线程资源的利用效率。此外，借助Akka-Cluster和Akka-Sharding的能力实现横向扩展，通过部署多个服务节点组成集群，聚合根对象可以在集群节点之间灵活调度，使得系统可以通过增加节点的方式提升处理能力。

Phoenix框架提供应用系统的伸缩性。与横向扩展相似，Phoenix服务集群可以动态缩减节点数量。Akka-Cluster和Akka-Sharding可以对聚合根对象进行集群调度和管理，在集群减少服务节点数量时，Akka可以将这些节点中的聚合根对象转移到剩余节点中。在进行节点移除的过程中，配合EventSourcing的能力，被移除节点中的聚合根可以在剩余节点中重新构建并恢复状态。

### 高可用
高可用性指系统无中断地执行其功能的能力，代表系统的可用性程度。是进行系统设计时的准则之一。高可用性系统与构成该系统的各个组件相比可以更长时间运行。高可用性通常通过提高系统的容错能力来实现。

系统的高可用性可以使用以下两个指标衡量：
1. 恢复时间目标(RTO)：RTO指在业务可接受的范围内，应用系统最多可以中断或关闭（业务不可用）多长时间。
2. 恢复点目标(RPO)：RPO指在业务可接受的范围内，应用系统最多可在系统故障恢复后丢失多长时间的业务数据。

Phoenix框架提供的高可用性同样基于Akka集群调度能力和EventSourcing，服务在集群部署的情况下，可以应对一定数量的节点故障。在出现节点故障时，Akka通过集群调度能力将故障节点的聚合根对象转移到剩余节点中，配合EventSourcing能力恢复聚合根对象的状态。由于EventSourcing的过程中有快照的支持，可以加速状态恢复，所以这些聚合根对象可以在较短时间内恢复，继续提供服务。

### 全面监控
Phoenix-Admin是配合Phoenix框架使用的服务监控平台，能够实现对多个项目，多服务，多实例层级的监控和内存管理的功能。微服务化的系统架构下，服务模块数量众多，加之每个领域服务都可以各自进行集群化多活部署，服务实例的数量只增不减，这对系统的监控和运维带来极大挑战。Phoenix-Admin通过注册中心对各服务实例进行注册，配合Phoenix服务中提供的服务监控管理接口，提供了不少方便监控和运维管理的手段。


## 框架服务模型
Phoenix是一套（准）微服务开发框架。在应用系统架构方面，提供了包括客户端开发、服务端开发、消息通讯架构、服务端状态数据存储和恢复、计算层和消息层监控、服务端运维等架构方案。而在业务开发方面，Phoenix提供了一套领域驱动设计模式(DDD)的实现模型，业务开发中的领域模型定义以聚合根(Aggregate Root)的形式作为业务计算的基本单元，在整个业务计算的流程中，聚合根对象之间仅以消息(Message)作为数据交互接口。框架对聚合根对象的状态管理和多层次交互的实现进行了封装。

### 业务开发模型
* 聚合根 Aggregate Root
* 消息 Message
Phoenix框架封装了一套DDD实现方式，业务模型的划分和定义基于DDD领域模型，在框架中则是对应为一个聚合根(Aggregate Root)模型定义，其包含了该领域业务计算所需的上下文数据。一个领域模型可对应一个聚合根定义，在实际进行业务计算时，一个聚合根定义可生成不同实例，这些实例之间相互独立，有着独立的状态数据。而聚合根对象之间的数据交互则是通过消息(Message)，聚合根对象可以接收消息并对消息做出相应的处理，以更新自己的状态。聚合根是Phoenix框架业务和计算模型的最基本单元，它不仅是业务计算的载体和基本单位，也是框架进行计算调度的基本单位。框架在技术实现上使用Actor模型，每个Actor实例与一个聚合根对象对应，管理着聚合根对象的内存状态、消息收发处理和聚合根计算调度。

### 聚合根通信模型
Phoenix服务为有状态(Stateful)的内存计算(In-Memory)服务，有状态即业务的计算依赖于服务当前的状态，内存计算则是在进行业务计算时，其依赖的数据都已经预先加载到内存中，数据模型不依赖外部存储。对于具体业务模型而言，其数据模型不会直接映射外部存储（数据库）的数据模型，也就是说，这些数据模型的查询和修改，不依赖外部存储的数据模型，仅面向内存数据模型进行交互，这样便减少了因复杂的数据模型存储带来的性能影响。

内存计算为业务计算带来高性能，但同时也带来了服务数据可靠性的问题。为了保障Phoenix服务的状态能够可靠恢复，聚合根对象的所有状态变更都基于领域事件(DomainEvent)进行增量更新，所以聚合对象的状态可以通过重跑领域事件来恢复。储存这些领域事件的存储层即为EventStore，服务在运行期间将领域事件存储到EventStore中，如果某个服务节点发生宕机，则该节点可以在重启后从EventStore中读取相应的领域事件恢复出宕机前的状态，而这个过程即是EventSourcing。通过EventStore领域事件存储和EventSourcing状态恢复，我们在应对服务节点故障或聚合根对象数据失效时，有了可靠的恢复手段，从而保证了业务数据的可靠性。

另一方面，为了满足服务在高并发场景下的处理能力，框架借助Akka的Actor计算模型在线程级别上提供以聚合根对象为最小单位的并发粒度；同时基于Akka-Cluster和Akka-Sharding的实现，相同领域的Phoenix服务可以进行多节点集群部署，构建多活集群，集群中不同的聚合根对象均衡地分布在不同节点中，使得服务可以通过增加节点的方式对系统的处理能力进行横向扩展。

### 服务间通信模型
Phoenix架构中，业务计算以领域聚合根为基本单元，这些基本单元对应着实际业务的一个个实体对象，它们之间的数据交换通过相互发送消息进行。聚合根对象不仅需要和客户端进行数据交换，还要与其他领域的聚合对象进行数据交换，这些跨领域的聚合对象数据交互都通过消息队列来实现。目前Phoenix消息通讯层使用Kafka实现，每个领域服务有其绑定的Topic，领域服务之间进行消息发送时根据服务名和目标聚合对象的信息进行路由。

Phoenix框架中客户端和服务端的数据交互基于消息队列，并且框架为客户端提供了业务调用接口。当领域聚合根模型和消息定义好之后，客户端通过消息通讯层向服务端发送相应的业务请求消息即可触发业务服务计算。在完成计算后，客户端可接收该请求的处理结果（同样为消息形式），完成一个业务请求的远程调用。业务调用为异步消息驱动，客户端或服务端调用方可以在发起调用后处理后续任务，实现非阻塞异步调用。同时，客户端也支持对业务的同步调用，调用线程在等待业务处理结果时被阻塞，至到业务处理结果被返回或调用超时。

### 查询端通信模型
Phoenix服务的业务开发基于消息驱动和DDD模式，这使得Phoenix服务同时可以方便进行读写分离的设计。我们可以将业务服务区分为两种类型，一种为写端服务(Command Side Service)，亦可称为C端服务，该类型的服务可以负责主业务流程的状态数据计算和管理，这些服务的数据属于数据一致性要求范围内。另一种服务类型为读端服务(Query Side Service)，亦可成为Q端服务，该类型服务可以作为业务数据一致性要求外的查询服务或分析服务等，这些查询或分析事务不署于业务主流程的事务内，但依赖于相同的业务数据。而这些业务数据我们能够通过消费读取C端服务产生的消息或领域事件来构建，以此实现读写分离。

所以通过以上Q端的实现方式，当应用系统的C端服务构建完成后，我们可以很方便地以Q端服务的形式构建监控和分析服务。基于这种实现方式，Phoenix提供了一套消息层监控分析方案。在应用系统中部署一个消息持久化服务消费所有Topic队列的消息，该服务会将消费到的消息持久化到Elasticsearch存储中，随后，我们便可以使用Grafana连接上Elasticsearch存储，对消息进行监控和分析。系统中流转的消息反应着系统的运行状态，如果能合理监控和分析这些消息，应用系统将具备业务告警、业务分析和问题排查等强大的能力。


## 行业案例
富国TSP平台案例介绍。。。。。。。。。

### 案例概述
富国TSP平台案例介绍。。。。。。。。。

### 案例特点
富国TSP平台案例介绍。。。。。。。。。

### 案例展示
富国TSP平台案例介绍。。。。。。。。。


## 总结展望
