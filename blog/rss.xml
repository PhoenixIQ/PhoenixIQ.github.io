<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Phoenix Blog</title>
        <link>http://phoenix-website.sz.iquantex.com/blog</link>
        <description>Phoenix Blog</description>
        <lastBuildDate>Mon, 06 Nov 2023 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh-cn</language>
        <item>
            <title><![CDATA[Phoenix 2.6.x Release]]></title>
            <link>http://phoenix-website.sz.iquantex.com/blog/2.6.x-release</link>
            <guid>http://phoenix-website.sz.iquantex.com/blog/2.6.x-release</guid>
            <pubDate>Mon, 06 Nov 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[我们很高兴 Phoenix 2.6.0 即将进入发布流程，本次版本升级涉及到了非常多的变动，但也进一步提升了 Phoenix 的性能，因此处于旧版本的用户可以尽早联系 Phoenix 团队获得体验版本]]></description>
            <content:encoded><![CDATA[<blockquote>
<p>我们很高兴 Phoenix 2.6.0 即将进入发布流程，本次版本升级涉及到了非常多的变动，但也进一步提升了 Phoenix 的性能，因此处于旧版本的用户可以尽早联系 Phoenix 团队获得体验版本</p>
</blockquote>
<!-- -->
<a class="link" href="http://phoenix-website.sz.iquantex.com/docs/phoenix/upgrade/2-6-x"><p>🎉&nbsp;<!-- -->完整发版日志 Release Notes <!-- -->&nbsp;🥳<!-- -->  &gt;&gt;</p></a>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="变动模块">变动模块<a href="http://phoenix-website.sz.iquantex.com/blog/2.6.x-release#%E5%8F%98%E5%8A%A8%E6%A8%A1%E5%9D%97" class="hash-link" aria-label="变动模块的直接链接" title="变动模块的直接链接">​</a></h2>
<ul>
<li>Phoenix Server</li>
<li>Phoenix Console</li>
<li>Phoenix Telemetry</li>
<li>Phoenix Subscribe</li>
<li>Phoenix EventPublish</li>
<li>Phoenix Transaction</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="api-增强">API 增强<a href="http://phoenix-website.sz.iquantex.com/blog/2.6.x-release#api-%E5%A2%9E%E5%BC%BA" class="hash-link" aria-label="API 增强的直接链接" title="API 增强的直接链接">​</a></h2>
<ul>
<li>PhoenixClient API 支持简化同步（无须 <code>Future.get()</code>) 语法:</li>
<li>命令支持优先级：<a href="http://phoenix-website.sz.iquantex.com/docs/phoenix-core/phoenix-core-entity-aggregate#%E5%A4%84%E7%90%86%E4%BC%98%E5%85%88%E7%BA%A7">文档说明</a>
<ul>
<li>Client API: <a href="http://phoenix-website.sz.iquantex.com/docs/phoenix-core/phoenix-core-client#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E4%BC%98%E5%85%88%E7%BA%A7">文档链接</a></li>
<li>SourceCollect API: <a href="http://phoenix-website.sz.iquantex.com/docs/phoenix-core/phoenix-subscribe-pub#%E4%B8%BA%E6%B6%88%E6%81%AF%E9%99%84%E5%8A%A0%E5%85%83%E6%95%B0%E6%8D%AE">文档链接</a></li>
</ul>
</li>
<li>PhoenixClient 支持定义 Kafka Producer Key，并且支持 Kafka 分区选择器 API: <a href="http://phoenix-website.sz.iquantex.com/docs/phoenix-core/phoenix-core-client#%E8%87%AA%E5%AE%9A%E4%B9%89-kafka-record-key">文档链接</a></li>
<li><a href="http://phoenix-website.sz.iquantex.com/docs/phoenix-advanced/aggregate-segment">聚合根片段代码特性</a></li>
<li><a href="http://phoenix-website.sz.iquantex.com/docs/phoenix-advanced/cluster-pool">集群线程池</a></li>
<li>等...</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-phoenix-server-变化">1. Phoenix Server 变化<a href="http://phoenix-website.sz.iquantex.com/blog/2.6.x-release#1-phoenix-server-%E5%8F%98%E5%8C%96" class="hash-link" aria-label="1. Phoenix Server 变化的直接链接" title="1. Phoenix Server 变化的直接链接">​</a></h2>
<p>整个 Phoenix Server 变化分为两个部分，分别是用户无感和可配置的部分：</p>
<ul>
<li>无感：Phoenix 升级底层 Actor 到 Typed Actor, 优化一些代码以提升性能(主要在 Actor 理念下优化)</li>
<li>有感：Phoenix 支持异步聚合根，提高聚合根 IO 效率，提升性能，文档链接：<a href="http://phoenix-website.sz.iquantex.com/docs/phoenix-core/phoenix-core-entity-aggregate#%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F">异步模式</a></li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-phoenix-console-变化">2. Phoenix Console 变化<a href="http://phoenix-website.sz.iquantex.com/blog/2.6.x-release#2-phoenix-console-%E5%8F%98%E5%8C%96" class="hash-link" aria-label="2. Phoenix Console 变化的直接链接" title="2. Phoenix Console 变化的直接链接">​</a></h2>
<p>Phoenix Console 在观感上可能是对用户改变最大的部分, 主要体现在 UI 变化以及模块的增加：</p>
<p><img loading="lazy" src="http://phoenix-website.sz.iquantex.com/assets/images/console-3a6f4f76d566480c4898ed46a4f7920d.png" width="1791" height="1137" class="img_ev3q"></p>
<p>部分变化的清单如下，详细说明请参考：<a href="http://phoenix-website.sz.iquantex.com/docs/phoenix-console/phoenix-console-service-management">PhoenixConsole</a></p>
<ul>
<li>新增集群状态统计（主要是聚合根在各个节点的分布）</li>
<li>新增简化性能监控</li>
<li>优化主页布局</li>
<li>优化内存查询聚合根速度</li>
<li>优化聚合根状态展示的前端性能</li>
<li>优化事件管理的查询性能，支持多种查询方式（如命令、聚合根类型等维度）</li>
<li>新增存活聚合根管理页面</li>
<li>新增 MetaData 管理页面</li>
<li>新增异常历史查询页面</li>
<li>新增线程饥饿检测器管理页面</li>
<li>优化事务聚合根调用链路展示</li>
<li>新增异常事件的异常堆栈展示</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-phoenix-apmtelemetry-变化">3. Phoenix APM/Telemetry 变化<a href="http://phoenix-website.sz.iquantex.com/blog/2.6.x-release#3-phoenix-apmtelemetry-%E5%8F%98%E5%8C%96" class="hash-link" aria-label="3. Phoenix APM/Telemetry 变化的直接链接" title="3. Phoenix APM/Telemetry 变化的直接链接">​</a></h2>
<p>Phoenix 在  2.6.x 对 APM 体系进行了重构，以便我们可以在保留 JMX 的同时，支持 <a href="https://opentelemetry.io/" target="_blank" rel="noopener noreferrer">OpenTelemetry</a> 的监控体系，也为后续支持 Traceing 提供一些基础。文档链接：<a href="http://phoenix-website.sz.iquantex.com/docs/phoenix-console/phoenix-console-system-monitor">PhoenixMetrics</a></p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>信息</div><div class="admonitionContent_BuS1"><p>需要注意的是，JMX 和 OpenTelemetry 监控方案无法同时引入，并且目前从 2.5.x 及之前升级的用户必须手动引入 OpenTelemetry/JMX 的依赖</p></div></div>
<p>相对于 JMX 提供的指标方式，OpenTelemetry 支持直方图的概念，在直方图下，延迟不再是平均的概念，能提供更全面的数据分布信息以及适应非均匀分布的数据（如极端值）</p>
<p>除此之外，OpenTelemetry 模式下，我们基于 LTW 实现了对 Akka Dispatcher 的指标监控埋点，这有助于分析 Phoenix 内部几个核心模块的负载以及性能</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-phoenix-subscribe-变化">4. Phoenix Subscribe 变化<a href="http://phoenix-website.sz.iquantex.com/blog/2.6.x-release#4-phoenix-subscribe-%E5%8F%98%E5%8C%96" class="hash-link" aria-label="4. Phoenix Subscribe 变化的直接链接" title="4. Phoenix Subscribe 变化的直接链接">​</a></h2>
<p>在 2.6.x 版本中，我们对 Phoenix Subscribe 遇到的一些问题进行了重构和增强，主要的优化是围绕在内存和使用层面。</p>
<p>Subscribe 中包含了三个部分：</p>
<ul>
<li>KafkaConsumer</li>
<li>SourceCollect</li>
<li>MetaData</li>
<li>可靠性投递</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="41-kafkaconsumer">4.1 KafkaConsumer<a href="http://phoenix-website.sz.iquantex.com/blog/2.6.x-release#41-kafkaconsumer" class="hash-link" aria-label="4.1 KafkaConsumer的直接链接" title="4.1 KafkaConsumer的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="streamsubscribe">StreamSubscribe<a href="http://phoenix-website.sz.iquantex.com/blog/2.6.x-release#streamsubscribe" class="hash-link" aria-label="StreamSubscribe的直接链接" title="StreamSubscribe的直接链接">​</a></h4>
<p>在 2.6.x 版本中我们引入了 Reactive Stream 版本的 <a href="http://phoenix-website.sz.iquantex.com/docs/phoenix-core/phoenix-subscribe-pub#stream-sub">StreamSubscribe</a>, 该 Subscribe 如 Reactive Stream 的描述一样不会让代码更快，而是尽可能快，
在此基础上能够获得更好的内存、延迟表现，实际测试时，我们在回归性能测试中发现 StreamSubscribe 的性能优于原本的 Subscribe 实现（具体原因暂未验证，猜测是 RC10 增加了大量的旁路线程），因此我们在 2.6.0 中将默认实现替代为 StreamSubscribe。</p>
<p>默认的 Subscribe 使用的 KafkaConsumer 是自旋模式，当下游消费速度变慢时会存在一定的空转，这会导致无效的对象生成开销以及消息响应的 ACK 处理延迟增加。</p>
<p><img loading="lazy" alt="img" src="http://phoenix-website.sz.iquantex.com/assets/images/stream-subscribe-26ca85c469b7a29de8b6fbf725fab7a1.png" width="885" height="666" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="分片算法">分片算法<a href="http://phoenix-website.sz.iquantex.com/blog/2.6.x-release#%E5%88%86%E7%89%87%E7%AE%97%E6%B3%95" class="hash-link" aria-label="分片算法的直接链接" title="分片算法的直接链接">​</a></h4>
<p>除了新增的 Subscribe 实现之外, 2.6.x 还为 Kafka Consumer 优化了分片算法，现在的 Kafka Consumer 的在集群中的分区基于分区维度的，在多分区下能更好的均匀各个节点的负载（无须任何配置）。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-clients-扩展">Kafka Clients 扩展<a href="http://phoenix-website.sz.iquantex.com/blog/2.6.x-release#kafka-clients-%E6%89%A9%E5%B1%95" class="hash-link" aria-label="Kafka Clients 扩展的直接链接" title="Kafka Clients 扩展的直接链接">​</a></h4>
<p>文档链接：<a href="http://phoenix-website.sz.iquantex.com/docs/phoenix-advanced/phoenix-kafka-extend">Kafka 扩展</a></p>
<p>开源的 Apache Kafka Clients 不支持发送超过 1m 以上的消息，可以通过调整参数的方式来解决此问题，但这会给 Broker 带来额外的开销（参考：<a href="https://www.slideshare.net/JiangjieQin/handle-large-messages-in-apache-kafka-58692297" target="_blank" rel="noopener noreferrer">Handle Large Messages In Apache Kafka</a></p>
<p>因此 Phoenix 提供了 Apache Kafka Clients 的扩展，在 Producer 和 Consumer 端通过 Chunk 的方式解决大体积消息的传输，无须更改 Kafka 配置。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="42-sourcecollect">4.2 SourceCollect<a href="http://phoenix-website.sz.iquantex.com/blog/2.6.x-release#42-sourcecollect" class="hash-link" aria-label="4.2 SourceCollect的直接链接" title="4.2 SourceCollect的直接链接">​</a></h3>
<p>在 2.6.x 版本中，我们为 SourceCollect 增加了<a href="http://phoenix-website.sz.iquantex.com/docs/phoenix-core/phoenix-subscribe-pub#%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86">批量 API</a>。原有的 SourceCollect 不支持批量 API，但在某些外部交互中（如通过 Redis 查询配置），可能会导致 N+1 查询的问题，优化后的 SourceCollect API 能更好的契合 KafkaConsumer
批量拉取的特点。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="43-metadata">4.3 MetaData<a href="http://phoenix-website.sz.iquantex.com/blog/2.6.x-release#43-metadata" class="hash-link" aria-label="4.3 MetaData的直接链接" title="4.3 MetaData的直接链接">​</a></h3>
<p>旧版本的 MetaData 存在以下问题：</p>
<ul>
<li>重复注册</li>
<li>非指数退避(Exponential backoff)的重试算法</li>
<li>内存开销（在 SourceCollect 中的对象生成）</li>
<li>API 缺失（如 exist/contains）</li>
</ul>
<p>在 2.6.x 版本中，我们针对这些问题进行了优化，并提供了新的 API 文档：(<a href="http://phoenix-website.sz.iquantex.com/docs/phoenix-core/phoenix-subscribe-pub#%E5%B9%BF%E6%92%AD">广播机制</a>)。此外，我们还在 Console 中为用户提供了 MetaData 的查询页面。</p>
<p>然而，由于设计上 MetaData 与可靠性投递耦合，并且持久化级别是分区级别的，因此在多分区场景下，我们目前不推荐使用 MetaData 代替 Redis。Redis 对于 Phoenix Server 来说是单点，可以减少大量流量。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="5-phoenix-eventpublish-变化">5. Phoenix EventPublish 变化<a href="http://phoenix-website.sz.iquantex.com/blog/2.6.x-release#5-phoenix-eventpublish-%E5%8F%98%E5%8C%96" class="hash-link" aria-label="5. Phoenix EventPublish 变化的直接链接" title="5. Phoenix EventPublish 变化的直接链接">​</a></h2>
<p>EventPublish 在历史上一直使用 <code>eventByTime</code> 的查询方式，在 2.6.x 中我们提供了 <code>eventBySlice</code> 作为改进方法。</p>
<p>使用 <code>eventByTime</code> 有一个缺点，那就是整个集群只能运行一个 EventPublish 实例，这意味着无法扩展到更多的 Phoenix 节点，导致 EventPublish 相对于插入出现延迟/间隙（Gap）的问题，在数据库索引的特性下，当查询索引的 Gap 足够大时，
索引将会被忽略(全表扫描)，这事因为优化器认为全表扫描的成本比使用索引更低，并且使用索引时还需要额外的多次 IO 来访问数据块（特定于 Phoenix EventPublish 场景）。</p>
<p>文档说明：<a href="http://phoenix-website.sz.iquantex.com/docs/phoenix-core/phoenix-core-event-store#%E5%88%87%E7%89%87%E6%A8%A1%E5%BC%8F">切片模式</a></p>
<p>2.6.x 提供的 <code>eventBySlice</code> 模式下将事件分区存储，并且根据用户选择的运行 EventPublish 的并行度不同，会在 0～1024 的范围为每个实例选择合适的分片。</p>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>备注</div><div class="admonitionContent_BuS1"><p>这种方式实际上是限制了分页的数量，在内部我们还使用了类似于 TCP 滑动窗口的概念，来缩短查询索引时的范围。除了这种方式外，我们还可以通过尽可能地使用索引覆盖
扫描的方式来优化偏移量非常大的分页，当目前我们并未引入两个优化，因为分区下查询速度已足够快。</p></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="6-phoenix-transaction-变化">6. Phoenix Transaction 变化<a href="http://phoenix-website.sz.iquantex.com/blog/2.6.x-release#6-phoenix-transaction-%E5%8F%98%E5%8C%96" class="hash-link" aria-label="6. Phoenix Transaction 变化的直接链接" title="6. Phoenix Transaction 变化的直接链接">​</a></h2>
<p>在旧版本我们接收到 Phoenix Transaction 的性能问题反馈，因此在 2.6.x 版本中，我们针对 Phoenix Transaction 存在的一些问题进行了性能优化：</p>
<ul>
<li>Console：事件管理中事件详情不展示事务聚合根接收的 Command 和 超时类 Event</li>
<li>Console：支持超时后，事务聚合根调用链路的展示</li>
<li>性能：事务聚合根支持全局维度的超时</li>
<li>性能：事务聚合根支持批处理</li>
<li>性能：事务聚合根心跳时，检查对象生成开销</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="漏洞修复优化">漏洞修复、优化<a href="http://phoenix-website.sz.iquantex.com/blog/2.6.x-release#%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E4%BC%98%E5%8C%96" class="hash-link" aria-label="漏洞修复、优化的直接链接" title="漏洞修复、优化的直接链接">​</a></h2>
<p>除此之外，本次 2.6.x 还包含了一些了 BUG 修复、体验优化的补丁，详情以及升级指南请见完整发版日志：<a href="http://phoenix-website.sz.iquantex.com/docs/phoenix/upgrade/2-6-x">2.6.X Release Notes</a></p>]]></content:encoded>
            <category>Phoenix</category>
            <category>Release</category>
        </item>
        <item>
            <title><![CDATA[Phoenix 性能调优]]></title>
            <link>http://phoenix-website.sz.iquantex.com/blog/phoenix-tuning</link>
            <guid>http://phoenix-website.sz.iquantex.com/blog/phoenix-tuning</guid>
            <pubDate>Sat, 22 Jul 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[本文介绍了对 Phoenix 进行性能调优的必要条件，包括了了解 Phoenix 的内部主要流程图和利用监控指标进行性能瓶颈分析。]]></description>
            <content:encoded><![CDATA[<p>本文介绍了对 Phoenix 进行性能调优的必要条件，包括了了解 Phoenix 的内部主要流程图和利用监控指标进行性能瓶颈分析。</p>
<p>在做性能调优时，首先要保证能够给定足够的负载，如增加 Kafka Topic 的分区数量（避免流量因部分聚合根处理过慢而阻塞）、增加 buffer 大小（避免所有聚合根处理过慢）、调整事务完成结果批次大小等措施。</p>
<p>同时，还介绍了 Phoenix 扩容措施。</p>
<!-- -->
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="requirement">0. 必要条件<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-tuning#requirement" class="hash-link" aria-label="0. 必要条件的直接链接" title="0. 必要条件的直接链接">​</a></h2>
<p>如果需要对 Phoenix 的性能进行调优，以实现硬件性能下的最高利用率，则首先需要了解 Phoenix 的内部主要流程图:</p>
<blockquote>
<p>Phoenix 内部结构的简化版视图如下</p>
</blockquote>
<p><img loading="lazy" alt="image" src="http://phoenix-website.sz.iquantex.com/assets/images/architecture-cddb480b902a070a9400100a4b6f7665.png" width="1779" height="446" class="img_ev3q"></p>
<p>其次，我们需要利用完善的监控指标，来帮助我们快速分析性能瓶颈点，目前我们总是推荐用户使用最新版本的 <code>phoenix-telemetry-otel</code>(详细文档请参考:<a href="http://phoenix-website.sz.iquantex.com/docs/phoenix-console/phoenix-console-system-monitor">Phoenix Metrics</a>)，
基于 OpenTelemetry 的埋点实现增加了直方图的支持（JMX 实现上较困难），并且丰富了一些指标埋点。对于可视化指标，我们推荐 Grafana 版本是 8.5.6，过低的版本将会无法运行。</p>
<p>此外，还需要 Phoenix 的 Akka Agent 以便与增加 akka-dispatcher（actor 运行线程池）的监控埋点（如需要请联系 Phoenix 团队）</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="source">1. 数据源调优<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-tuning#source" class="hash-link" aria-label="1. 数据源调优的直接链接" title="1. 数据源调优的直接链接">​</a></h2>
<p>要实现 Phoenix 的性能优化，首先要保证给定了足够的负载，因为 Phoenix 的数据来源主要是 Kafka，所以本质上 Phoenix 在负载模型(workload model)中属于封闭模型(closed model)，也就是 Phoenix 会限制并发的数量（Phoenix 借助
Kafka 将多余流量推入队列），如需了解更多负载模型的背景，请参考论文：<strong>《Open Versus Closed: A Cautionary Tale》</strong></p>
<p>在头图的架构中，1、2、7 组成了 Phoenix 数据源流速的简化部分，详细的内部流程图如下：</p>
<p><img loading="lazy" alt="image" src="http://phoenix-website.sz.iquantex.com/assets/images/perf-01-8358586b550efa882e4475817c63892f.png" width="925" height="355" class="img_ev3q"></p>
<p>由上图可知，Phoenix 用一个 Buffer 控制并发（或者说控制流量的流入速率），仅当消费者的消费速率（聚合根的处理速度）足够时，才会再次摄入消息，此外 EventStore 的负载或多或少也会影响到
数据源的吞吐能力，因为：</p>
<ol>
<li>数据源（ReceiverActor）是独占单线程，同时负责 KafkaConsumer，可靠性投递，接收聚合根处理完成的结果</li>
<li>可靠性投递和聚合根共享同一个 EventStore（默认配置下）</li>
</ol>
<p>因此，为了能让 Phoenix 数据源的给到聚合根的负载足够（聚合根支持批量操作），聚合根的并发能力才能上升，所以通常我们有以下措施：</p>
<ol>
<li>增加 Kafka Topic 的分区数量：增加分区意味着直接增加了并行度，此时 buffer 也会成倍增加，此外增加分区还可以利用 Key Hash，支持让不同聚合根的命令分散到不同的分区，避免单个聚合根阻塞了整个数据源</li>
<li>增加 buffer 大小：<code>quantex.phoenix.server.mq.properties.limitMaxLiveThings</code>（增加 buffer 会导致缓存的消息数量增多，请注意内存开销）</li>
<li>调整事务完成结果批次大小：<code>quantex.phoenix.server.mq.properties.finishThingsBatch</code>（更大的批次对于 EventStore 的压力更小，阻塞更少，但 buffer 窗口移动的速度更慢）</li>
</ol>
<p>数据源调优的目的是为了<strong>保证聚合根并发足够</strong>：消息摄入够快，够分散（多个聚合根能同时并发）</p>
<p>对于聚合根的并发是否足够，可通过 Phoenix Metrics 中 Akka-Dispatcher 观察线程池的使用率：</p>
<blockquote>
<p>下图通过 活跃线程数量/线程池大小 来计算得出线程池的利用率，从而得出聚合根的并发是否足够</p>
</blockquote>
<p><img loading="lazy" alt="image" src="http://phoenix-website.sz.iquantex.com/assets/images/perf-02-e478ec6cc89578814f1fa0c7cb941c40.png" width="2496" height="352" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="handle">2. 聚合根处理调优<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-tuning#handle" class="hash-link" aria-label="2. 聚合根处理调优的直接链接" title="2. 聚合根处理调优的直接链接">​</a></h2>
<p>当数据源能够提供足够的流速和消息分散度后，整个 Phoenix 的性能则完全取决于聚合根的处理速度。</p>
<p>在聚合根层面，Phoenix 为用户新增了一个攒批的实现（当聚合根空闲时立即发送消息缓存 / 当消息满足一定批次大小后直接发送消息缓存），以此提高聚合根处理速度（避免每个 Command 都会发生一次持久化的网络 I/O，从而导致
性能降低，网络 I/O 通常是最大的瓶颈点）</p>
<blockquote>
<p>下图展示了攒批的层次，攒批和实际处理的聚合根并不在一个线程池中，后者的任务更繁重，因此做了隔离以提高攒批线程池的运行效率（避免任务阻塞在任务队列）</p>
</blockquote>
<p><img loading="lazy" alt="image" src="http://phoenix-website.sz.iquantex.com/assets/images/perf-03-1b725a86584e9b0a76bfc53105010183.png" width="1105" height="436" class="img_ev3q"></p>
<p>对于 Aggregate 而言，聚合根处理消息的响应时间主要由以下部分组成：</p>
<ol>
<li>Batch 等待调度耗时（默认情况下，总是微妙级别）</li>
<li>Batch 攒批耗时（取决于 Child 的处理时间）</li>
<li>聚合根等待调度耗时（聚合根线程池的负载通常更高，处理时间更长，因此发送给聚合根的消息，等待调度的时间是个重要的指标）</li>
<li>聚合根处理耗时（取决于用户代码）</li>
<li>聚合根持久化耗时（持久化数据的 I/O 耗时，在异步模式下，此耗时还包含数据库响应的调度时间）</li>
</ol>
<p>调度耗时可以在 Akka-Dispatcher 监控中找到，在同步模式下，聚合根线程池为 <code>aggregate-dispatcher</code>，Batch 的线程池为 <code>akka.actor.default-dispatcher</code></p>
<p><img loading="lazy" alt="image" src="http://phoenix-website.sz.iquantex.com/assets/images/perf-04-dc7fb961bc6905042788245ab412f4ce.png" width="684" height="338" class="img_ev3q"></p>
<p>聚合根的处理和持久化耗时，可以在 Phoenix Performance 监控面板中找到，也可以在 Phoenix Source Aggregate 中找到</p>
<p><img loading="lazy" alt="image" src="http://phoenix-website.sz.iquantex.com/assets/images/perf-05-390181c68216aca9b9087c0fd96fd528.png" width="712" height="402" class="img_ev3q"></p>
<p>对于聚合根处理的调优，可以从以下几个方面入手：</p>
<ol>
<li>聚合根等待调度耗时过高（观察处理和持久化，哪一个的耗时过高，从而影响了聚合根线程池的处理耗时 -&gt; 调度耗时）</li>
<li>聚合根持久化耗时过高（可使用聚合根异步运行模式尝试优化，如无法提高，观察 EventStore 指标，是否数据库到达瓶颈）</li>
<li>聚合根处理耗时过高（尝试优化代码，或者调低批量处理大小，调低批量处理后能让聚合根线程池的公平策略提高）</li>
</ol>
<p>通常在聚合根内，我们不建议内部包含阻塞，I/O 行为，从上面可得知，一旦聚合根线程池处理耗时提高，那么等待调度的耗时就会增加，继而影响聚合根响应时间 -&gt; 事务耗时</p>
<p>聚合根运行在 Actor 模型中，而 Actor 模型通过事件驱动的方式，模拟出虚拟线程（纤程）的效果，而当聚合根阻塞越严重，则该效果越差。</p>
<p>当然，用户也可以通过提高聚合根线程池大小的方式，让聚合根从事件驱动模型退化到线程池模型，但此时 EventStore 的攒批效果则大大降低。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="event-publish">3. EventPublish 调优<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-tuning#event-publish" class="hash-link" aria-label="3. EventPublish 调优的直接链接" title="3. EventPublish 调优的直接链接">​</a></h2>
<p>EventPublish 是一个相对独立的模块，可以不依赖于 Phoenix Server 而运行。</p>
<p>EventPublish 的结构并不复杂，核心主要是一个 Reader 从 EventStore 中按顺序读取事件，并通过 Handler 处理之后发送到 Kafka，如下图所示：</p>
<p><img loading="lazy" alt="image" src="http://phoenix-website.sz.iquantex.com/assets/images/perf-06-641b9e77c2d167be7a1550878f20b97f.png" width="662" height="505" class="img_ev3q"></p>
<p>EventPublish 提供用于调优性能的配置如下：</p>
<ul>
<li><code>quantex.phoenix.event-publish.batch-size</code>：每次从 EventStore 读取的批次大小，默认是 128</li>
<li><code>quantex.phoenix.event-publish.buffer-queue-size</code>：Reader 和 Handler 之间缓存事件的队列大小，默认是 64</li>
</ul>
<p>需要注意的是，EventPublish 在读取 EventStore 时使用了两个参数：已处理的 offset（时间戳）和（当前最大的事务时间戳 - 1）作为范围查询，该数据库列拥有一个索引用于加速查询。</p>
<p>然而，当 EventPublish 的消费远远落后于聚合根持久化的事件生产速度时，索引范围查询太多，从而让数据库优化器放弃使用索引，转而使用全表扫描，这会导致查询的性能急剧下降。</p>
<p>为了避免该问题，我们在 EventStore 的 Slice 模式中支持了两个特性：</p>
<ol>
<li>支持并发消费（通过一个 slice 字段切分被分片的行）</li>
<li>智能化范围查询（当前 offset 向前的窗口查询依赖于上一次查询的结果，尽可能保证索引命中的行数低于数据库优化器放弃使用索引的阈值）</li>
</ol>
<p>除此之外，在 Timer 模式中（默认）也可以通过增加每次从 EventStore 读取的批次大小，也就是增加消费速度和队列大小，避免 EventPublish 远落后于事件生产速度（EventPublish 主要的瓶颈还是查库）</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="event-sourcing">4. 溯源时间过长<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-tuning#event-sourcing" class="hash-link" aria-label="4. 溯源时间过长的直接链接" title="4. 溯源时间过长的直接链接">​</a></h2>
<p>在单个分区下，如果原始流量的分布不均匀（如前 1w 个事件都是某个聚合根），这会导致 Phoenix 出现单线程处理的情况（聚合根处理是单线程，符合 Actor 模型）这种情况可通过在 Phoenix Metrics 观察多个面板分析（主要是 akka dispatcher + aggregate）</p>
<p>除了原始流量不均之外，当某个聚合根发生异常并进入溯源时，该聚合根会停止处理消息并等待溯源完毕，这种情况下，假设该聚合根流量较大（即使是每秒 100 t/S，也会在 10s 内将 ReceiverActor 的 Buffer 撑满）将会造成背压限流，从而影响 Phoenix 的吞吐能力。</p>
<p><img loading="lazy" alt="image" src="http://phoenix-website.sz.iquantex.com/assets/images/perf-07-fcf1c0b710f8755e1028413f9c70b93f.png" width="1226" height="362" class="img_ev3q"></p>
<p>解决方案有三种方式：</p>
<ol>
<li>为聚合根增加独立的背压 buffer（框架目前暂不支持，未来可能支持）</li>
<li>减少聚合根 <code>on()</code> 处理耗时, 以此降低 EventSourcing 时间</li>
<li>减少聚合根快照周期<code>snapshotInterval</code>（这种情况下聚合根可能会频繁快照，取决于聚合根的流量）</li>
</ol>
<p>目前我们更推荐第二种方式的调优，在 EventSourcing 的思想中，Event 是不可变的事实，而 <code>on()</code> 方法则是 <code>State -&gt; Event -&gt; State</code> 的表达，也就是事件改变状态。
任何涉及到计算、外部依赖的操作都应该在 Command 阶段完成，最终通过不可变量的方式存储在 Event 中。</p>
<p>这种情况和数据源的调优一样，都属于聚合根并发不足。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="scale-up">5. 扩容<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-tuning#scale-up" class="hash-link" aria-label="5. 扩容的直接链接" title="5. 扩容的直接链接">​</a></h2>
<p>通常，提升一个应用的性能最简单暴力的方法就是 Scale Up 和 Scale Out.</p>
<ul>
<li>ScaleUp：同节点数量下，增加部署 Phoenix 应用的 CPU 核心数量（线程池数量会随着 CPU 核心而增长）</li>
<li>ScaleOut：在 CPU 核心数量保持不变下，增加 Phoenix 集群节点数量</li>
</ul>
<p>如果 ScaleUp 后性能没有提升，则通过 Akka-Dispatcher 观察线程池利用率，观察是否聚合根并发不够。</p>
<p>如果 ScaleOut 后性能没有提升，则观察数据源摄入速率是否足够，聚合根并发是否足够。</p>
<p>此外，还有一种情况是聚合根拆分的粒度不够导致聚合根的并发不足，例如将所有应该拆分的聚合根放到一个大单体，此时无论如何扩容，那么性能都无法提升，因为此时 Phoenix 只会单线程池处理。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="cpu-bound">6. CPU 密集型<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-tuning#cpu-bound" class="hash-link" aria-label="6. CPU 密集型的直接链接" title="6. CPU 密集型的直接链接">​</a></h2>
<p>上述的调优显然更适合 I/O 密集型场景应用，当然部分也适用于 CPU 密集型应用。</p>
<p>对于 CPU 密集型应用，其性能完全取决于给定的节点配置（CPU 核心数量）以及集群节点数量，都是可以通过利特尔法则计算得出：</p>
<p>假设 CPU 密集型任务需要执行 30ms，硬件配置为 8 个核心和 3 个集群节点。在这种情况下，可以使用以下公式计算理论吞吐量：</p>
<blockquote>
<p>吞吐量 = 核心数 / 平均响应时间</p>
</blockquote>
<p>平均响应时间可以近似为计算任务的耗时，即 30ms。 因此根据硬件配置，理论上的吞吐量为：</p>
<blockquote>
<p>吞吐量 = 8 / 0.03s * 3 = 800 TPS（每秒事务数）</p>
</blockquote>
<p>当 CPU 密集任务不会占用全部的 CPU 算力时，如聚合根已处理完，进入持久化流程，此时聚合根的线程池能够突破该 TPS，直到再次进入 CPU 密集。</p>
<p>目前对于 CPU 密集型任务，主要的瓶颈点还是硬件算力，只能通过增加算力来扩展，暂无调优手段。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="event-store">7. EventStore 瓶颈<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-tuning#event-store" class="hash-link" aria-label="7. EventStore 瓶颈的直接链接" title="7. EventStore 瓶颈的直接链接">​</a></h2>
<p>Phoenix 目前提供了 EventStore-JDBC 作为 EventSourcing 的持久化存储，EventStore 基于 RDBMS 为提供了一些特性（唯一、幂等索引，Console 查询）
但是目前单节点的 RDBMS 在大多数情况中都容易成为 Phoenix 应用的瓶颈点。</p>
<p>对于因 EventStore 导致应用出现瓶颈的情况，请考虑如下方案：</p>
<ol>
<li>物理机部署数据库</li>
<li>在固态硬盘之上运行数据库</li>
<li>配置多数据源</li>
<li>使用分布式SQL数据库（如 TiDB、YugabyteDB）</li>
</ol>]]></content:encoded>
            <category>Phoenix</category>
            <category>Performance</category>
            <category>Tuning</category>
        </item>
        <item>
            <title><![CDATA[Phoenix 使用场景介绍]]></title>
            <link>http://phoenix-website.sz.iquantex.com/blog/phoenix-scene</link>
            <guid>http://phoenix-website.sz.iquantex.com/blog/phoenix-scene</guid>
            <pubDate>Tue, 14 Sep 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[本章分析了贫血模型和充血模型的优缺点以及使用场景，进而表明Phoenix的适用场景。]]></description>
            <content:encoded><![CDATA[<blockquote>
<p>本章分析了贫血模型和充血模型的优缺点以及使用场景，进而表明Phoenix的适用场景。</p>
<p>本章下面贫血模型和充血模型分析部分内容引用了王争在极客时间<a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener noreferrer">设计模式之美</a>课程。</p>
</blockquote>
<!-- -->
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="什么是贫血模型">什么是贫血模型?<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-scene#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B" class="hash-link" aria-label="什么是贫血模型?的直接链接" title="什么是贫血模型?的直接链接">​</a></h2>
<p>贫血模型最早广泛应用是源自于EJB2，把<code>行为</code>（也称为方法、过程）和<code>状态</code>（可理解为数据，对应到语言就是对象成员变量）分离到不同的对象之中。 那个只有状态的对象就是所谓的“贫血对象”（PO/DTO），而那个只有行为的对象就是我们常见的三层结构中的Service/Manager层。</p>
<p>实际上，你可能一直都在用贫血模型做开发，只是自己不知道而已。据了解，绝大多数的业务后端系统，都是基于贫血模型的。下面用一个银行账户的例子说明一下。</p>
<p>下面实现了简单的银行账户，可以对账户做余额的划拨操作(加钱或者扣钱)。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">////////// Service+BO(Business Object) //////////</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">class</span><span class="token plain"> </span><span class="token class-name">AccountService</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">AccountRepository</span><span class="token plain"> accountRepository</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//通过构造函数或者IOC框架注入</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">allocateAmt</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name">Double</span><span class="token plain"> amt</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token class-name">AccountEntity</span><span class="token plain"> accountEntity </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> accountRepository</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">getAccount</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">userId</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token class-name">AccountBo</span><span class="token plain"> accountBo </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">convert accountEntity </span><span class="token keyword" style="color:#00009f">to</span><span class="token plain"> </span><span class="token namespace" style="opacity:0.7">accountBo</span><span class="token namespace punctuation" style="opacity:0.7;color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        accountBo</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">amt </span><span class="token operator" style="color:#393A34">+=</span><span class="token plain"> amt</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        accountEntity </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">convert accountBo </span><span class="token keyword" style="color:#00009f">to</span><span class="token plain"> </span><span class="token namespace" style="opacity:0.7">accountEntity</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        accountRepository</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">update</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">accountEntity</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">class</span><span class="token plain"> </span><span class="token class-name">AccountBo</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token comment" style="color:#999988;font-style:italic">//省略其他属性、get/set/construct方法</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">Long</span><span class="token plain"> id</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">String</span><span class="token plain"> name</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">String</span><span class="token plain"> amt</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">////////// Repository+Entity //////////</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">class</span><span class="token plain"> </span><span class="token class-name">AccountRepository</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token class-name">AccountEntity</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">getUserById</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name">Long</span><span class="token plain"> userId</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//... }</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">class</span><span class="token plain"> </span><span class="token class-name">AccountEntity</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token comment" style="color:#999988;font-style:italic">//省略其他属性、get/set/construct方法</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">Long</span><span class="token plain"> id</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">String</span><span class="token plain"> name</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">String</span><span class="token plain"> amt</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>像AccountBo这种只包含数据，操作方法在Service中的实现就叫做贫血模型。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="什么是充血模型">什么是充血模型?<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-scene#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B" class="hash-link" aria-label="什么是充血模型?的直接链接" title="什么是充血模型?的直接链接">​</a></h2>
<p>在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。</p>
<p>在充血模型当中，会引入domain这一层，把核心业务的数据和方法都写在Domain当中。充血模型是一种重业务的实现方式，要求程序员在研发之初
要做充分的业务分析和设计，<a href="https://medium.com/the-coding-matrix/ddd-101-the-5-minute-tour-7a3037cf53b8" target="_blank" rel="noopener noreferrer">DDD(领域驱动设计)</a>是一种比较好的指导思想。还用上面银行账户的例子感受一下。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">////////// Service负责domain对象持久化转换 //////////</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">class</span><span class="token plain"> </span><span class="token class-name">AccountService</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">AccountRepository</span><span class="token plain"> accountRepository</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//通过构造函数或者IOC框架注入</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">allocateAmt</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name">Double</span><span class="token plain"> amt</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token class-name">AccountEntity</span><span class="token plain"> accountEntity </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> accountRepository</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">getAccount</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">userId</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token class-name">AccountBo</span><span class="token plain"> accountBo </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token class-name">AccountDomain</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">load</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">accountEntity</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        accountBo</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">allocate</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">amt</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        accountEntity </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">convert accountBo </span><span class="token keyword" style="color:#00009f">to</span><span class="token plain"> </span><span class="token namespace" style="opacity:0.7">accountEntity</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        accountRepository</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">update</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">accountEntity</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">class</span><span class="token plain"> </span><span class="token class-name">AccountDomain</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">Long</span><span class="token plain"> id</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">String</span><span class="token plain"> name</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">Double</span><span class="token plain"> amt</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">static</span><span class="token plain"> </span><span class="token class-name">AccountDomain</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">load</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name">AccountEntry</span><span class="token plain"> entry</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">{</span><span class="token comment" style="color:#999988;font-style:italic">//...}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">allocateAmt</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name">Double</span><span class="token plain"> amt</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">this</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">amt </span><span class="token operator" style="color:#393A34">+=</span><span class="token plain"> amt</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">////////// Repository+Entity //////////</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">class</span><span class="token plain"> </span><span class="token class-name">AccountRepository</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token class-name">AccountEntity</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">getUserById</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name">Long</span><span class="token plain"> userId</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//... }</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">class</span><span class="token plain"> </span><span class="token class-name">AccountEntity</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token comment" style="color:#999988;font-style:italic">//省略其他属性、get/set/construct方法</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">Long</span><span class="token plain"> id</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">String</span><span class="token plain"> name</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">Double</span><span class="token plain"> amt</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>AccountDomain既包含了数据还包含了账户划拨的方法，是真正的面向对象的编程方式。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="使用场景分析">使用场景分析<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-scene#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90" class="hash-link" aria-label="使用场景分析的直接链接" title="使用场景分析的直接链接">​</a></h2>
<p>接下来我们分别看一下贫血模型和充血模型都适合哪些场景，上面的例子当中，无论是贫血模型和充血模型
都可以实现，并且看起来复杂度也差不多，虽然贫血模型是面向过程的，但由于业务简单，也没什么不好。如果我们
增大业务复杂度，来看看两种模型是否有本质区别。</p>
<p>增加需求：</p>
<ol>
<li>需要账户余额支持多币种。</li>
<li>在多币种之上需要根据汇率实时计算不同币种的市值。</li>
<li>余额增加冻结和解冻操作。</li>
<li>在冻结和解冻之上需要提供总金额和可用金额计算。</li>
<li>假设该账户是证券账户，投资了股票，需要实时根据行情计算收益。</li>
<li>其他等等等。</li>
</ol>
<p>你可以再脑海当中使用贫血模型的开发方式构造一下如何完成这些需求。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="贫血模型场景分析">贫血模型场景分析<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-scene#%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90" class="hash-link" aria-label="贫血模型场景分析的直接链接" title="贫血模型场景分析的直接链接">​</a></h3>
<p>我们可以使用贫血模型的设计思路推演一下：</p>
<ol>
<li>给账户表设计并增加这些需求所需要的字段。</li>
<li>为了满足一些特定需求，增加很多自定义的sql，甚至会有join表查询（比如计算收益率join行情表）。</li>
<li>编写service，但是有可能逻辑会在sql，也有可能在service，也有可能特殊的逻辑用特殊的sql实现，导致sql满天飞。</li>
<li>Bo,Vo,Entry增加相关字段。</li>
</ol>
<p>这种开发方式是典型的SQL驱动的开发模式，这样将会导致逻辑不内聚，代码复用性不高，新的开发人员很难通过代码读清楚逻辑，并且单元测试难以编写，随着更多需求加入，整个工程就会臃肿起来，变得难以维护和测试。</p>
<p>那么为什么贫血模型的种种弊端会被广大程序员所接受呢？有以下几个原因：</p>
<ol>
<li>大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于 SQL 的 CRUD 操作，所以，我们根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的开发工作。除此之外，因为业务比较简单，即便我们使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义。</li>
<li>充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在 Service 层定义什么操作，不需要事先做太多设计。</li>
<li>思维已固化，转型有成本。基于贫血模型的传统开发模式经历了这么多年，已经深得人心、习以为常。你随便问一个旁边的大龄同事，基本上他过往参与的所有 Web 项目应该都是基于这个开发模式的，而且也没有出过啥大问题。如果转向用充血模型、领域驱动设计，那势必有一定的学习成本、转型成本。很多人在没有遇到开发痛点的情况下，是不愿意做这件事情的。</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="充血模型场景分析">充血模型场景分析<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-scene#%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90" class="hash-link" aria-label="充血模型场景分析的直接链接" title="充血模型场景分析的直接链接">​</a></h3>
<p>我们可以尝试再使用充血模型的设计思路推演一下：</p>
<ol>
<li>充分分析业务需求，通过DDD的设计指导思想，划分领域。</li>
<li>提出Account领域所设计的功能，设计对象，方法。</li>
<li>直接对该领域先进行编程实现业务代码。</li>
</ol>
<p>实际上，上面提到的需求都是AccountDomain的边界，在我们充分理解业务需求之后，即可直接对现有的AccountDomain代码进行开发。可以参考下面代码示例</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">class</span><span class="token plain"> </span><span class="token class-name">AccountDomain</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">Long</span><span class="token plain"> id</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">String</span><span class="token plain"> name</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// key = 币种 value = 余额</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">Map</span><span class="token generics punctuation" style="color:#393A34">&lt;</span><span class="token generics class-name">String</span><span class="token generics punctuation" style="color:#393A34">,</span><span class="token generics"> </span><span class="token generics class-name">Double</span><span class="token generics punctuation" style="color:#393A34">&gt;</span><span class="token plain"> currencyAmt</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">Double</span><span class="token plain"> frozenAmt</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 股票持仓 (Position是该领域下又一个实体对象)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token class-name">Map</span><span class="token generics punctuation" style="color:#393A34">&lt;</span><span class="token generics class-name">String</span><span class="token generics punctuation" style="color:#393A34">,</span><span class="token generics"> </span><span class="token generics class-name">Position</span><span class="token generics punctuation" style="color:#393A34">&gt;</span><span class="token plain"> position</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">static</span><span class="token plain"> </span><span class="token class-name">AccountDomain</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">load</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name">AccountEntry</span><span class="token plain"> entry</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">{</span><span class="token comment" style="color:#999988;font-style:italic">//...}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">allocateAmt</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name">Double</span><span class="token plain"> amt</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">this</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">amt </span><span class="token operator" style="color:#393A34">+=</span><span class="token plain"> amt</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 获取总资产(RMB)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token class-name">Double</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">getAllAsset</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic">// 遍历所有币种计算市值 + 股票持仓市值</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic">// 伪代码：currentcyAmt.values().stream(sum) + position.values().stream.stram(getQty * marketValue);    </span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 冻结余额</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">frozenAmt</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">double</span><span class="token plain"> amt</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        frozenAmt </span><span class="token operator" style="color:#393A34">+=</span><span class="token plain"> amt</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 其他等等方法都按照直接该类的角度上编写即可。</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">class</span><span class="token plain"> </span><span class="token class-name">AccountDomainTest</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token comment" style="color:#999988;font-style:italic">// 测试代码也很好编写，不依赖任何中间件，直接构造自己的数据放到对象里面调用对应方法断言即可.</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>看到这里相信你应该能get到充血模型的好处了吧，当然你会问，只写一个领域层代码肯定不行，这个对象如何和数据库打交道呢？不还是要定义service,repository来做消息调用和持久化吗?</p>
<p>是的，需要定义这些，但是这些都是辅助domain完成非功能需求，核心的业务代码都内聚在这个domain里面了。实际上越来越多的实践表明，在充血模型下，表结构设计变得不那么重要，你甚至都可以使用NoSQL(MongoDB)，把对象序列化后存进去，需要的时候，再取出来反序列化都可以。</p>
<p>经过上面对比分析，那么什么时候该考虑使用充血模型开发模式呢？</p>
<p>基于贫血模型的传统的开发模式，比较适合业务比较简单的系统开发。相对应的，基于充血模型的 DDD 开发模式，更适合业务复杂的系统开发。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。</p>
<p>我们知道，越复杂的系统，对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。而基于充血模型的 DDD 开发模式，正好需要我们前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="非功能场景分析">非功能场景分析<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-scene#%E9%9D%9E%E5%8A%9F%E8%83%BD%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90" class="hash-link" aria-label="非功能场景分析的直接链接" title="非功能场景分析的直接链接">​</a></h3>
<p>上面分别介绍了贫血模型，充血模型的优缺点和适用场景。不过，对于完整的系统来说，
无论是充血模型还是贫血模型的系统都会有很多非功能性需求。用户除了完成业务功能外，还需要考虑这些非功能需求，
下面表格简单分析了完成这些非功能需求的技术选型以及用户使用门槛。</p>
<table><thead><tr><th>非功能需求</th><th>实现方式</th><th>使用门槛</th></tr></thead><tbody><tr><td>事务保障</td><td>本地事务保障可以依赖关系型数据库来完成，借助ORM框架可以比较方便的操作数据库</td><td>中</td></tr><tr><td>高可用</td><td>在一个系统中，高可用至关重要，一般高可用要根据所用技术和所依赖的中间件做对应的设计。比如，可以使用RPC框架多点部署，然后客户端通过负载均衡来达到高可用</td><td>高</td></tr><tr><td>接口幂等</td><td>用户可能发送同样的业务请求，在后端需要对该请求做接口幂等，一般会依赖数据库唯一索引，识别用户主键ID来做，但是为了满足幂等，表结构设计会增加一些额外要素</td><td>高</td></tr><tr><td>扩缩容</td><td>扩容缩容是一件复杂的事情，虽然应用层是无状态可以容易做到，但是却把难点抛到了数据库，数据库的扩缩容不仅仅要涉及到分库分表(业务上拆分)，数据迁移，引入中间层（比如Mycat）等等。需要重点强调的是，在复杂业务场景，如何做分表是一件特别麻烦的事情，和业务的拆分息息相关。</td><td>高</td></tr><tr><td>高并发</td><td>设计高并发的系统首要是寻找并发粒度，有时候设计不完善的情况下，业务的并发粒度很难寻找，会导致各种行锁，表锁，甚至分布式锁，锁来锁去，也是个比较头疼的地方。</td><td>高</td></tr><tr><td>分布式事务</td><td>业务横向拆分(分库)，纵向拆分(服务化)后，都会带来一些分布式事务的问题，可以利用比如seata的中间件解决，但也需要对业务的一致性和隔离性做一定取舍</td><td>中</td></tr><tr><td>业务监控</td><td>系统运维人员希望对业务执行情况做实时监控，一般为了不耦合业务，会从数据库中反向解析形成另一套系统去做，通过实时分析计算技术去完成</td><td>高</td></tr><tr><td>可扩展性</td><td>有时候作为核心业务系统，其他系统希望接收该系统的行为做二次数据加工分析，那就对该系统的扩展性要求比较高。有些系统会在service层抓取动作，投递给MQ，有些系统则直接反向解析数据库日志。并且如果对时序要求较高时，也是比较难以处理的地方</td><td>高</td></tr></tbody></table>
<p>上面列举了一些完整系统还将会遇到的一些非功能性需求，并简单分析了实现方式。事实上，这些非功能需求互相之间都是有相互影响的，我们需要根据业务做具体取舍。但是这些其实都不是
业务领域核心的逻辑，充血模型可以指导用户写出的业务逻辑尽量不被这些非功能需求所影响。总体来说，实现非功能场景还有很高的门槛。</p>
<p>当个程序员好难，我只想好好写业务，帮助业务人员解决问题，肿么办？有没有一款框架能减低实现这些非功能需求的门槛？</p>
<p><img loading="lazy" alt="emoje" src="http://phoenix-website.sz.iquantex.com/assets/images/emoje-1-d0415ee661462944550b7dc03979b40f.png" width="440" height="436" class="img_ev3q"></p>
<p>也许你可以考虑使用Phoenix。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="使用phoenix开发充血模型代码">使用Phoenix开发充血模型代码<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-scene#%E4%BD%BF%E7%94%A8phoenix%E5%BC%80%E5%8F%91%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E4%BB%A3%E7%A0%81" class="hash-link" aria-label="使用Phoenix开发充血模型代码的直接链接" title="使用Phoenix开发充血模型代码的直接链接">​</a></h2>
<p>Phoenix是一款有状态分布式计算框架，旨在帮助业务开发人员降低复杂业务的分布式系统开发门槛。在Phoenix中，业务开发人员可以像面向对象编程一样，愉快的编写充血模型代码，而不需要过多考虑数据持久化，分布式计算，并发安全等一些非功能需求。</p>
<p>Phoenix中业务人员首先需要定义<code>聚合根</code>，聚合根是一个领域的入口，在运行时，会根据不同的<code>聚合根ID</code>产生不同的<code>聚合根对象</code>，聚合根对象是可以分部在各个节点当中并发运行的。Phoenix可以保证聚合根对象的事务特性(ACID)。</p>
<blockquote>
<p>聚合根对象实际上就是领域对象，你可以对比上面例子理解成是AccountDomain类产生的对象。</p>
</blockquote>
<p>如下图，一个AccountDomain运行时创建的所有对象会平均分布在各个Phoenix节点当中，当请求到来时，Phoenix会根据聚合跟ID路由到该节点当中，把请求给到对应的聚合根对象处理。
当一个JVM宕机时，Phoenix集群会自动把该节点中运行的聚合根对象飘逸到其他节点当中，继续承担任务。（实际上网络环境会有更多各式各样的故障，Phoenix做了混沌测试都可以保障可靠性，可以<a href="https://phoenix.iquantex.com/blog/2021/06/24/phoniex-openchaos" target="_blank" rel="noopener noreferrer">参考文章</a>）</p>
<p><img loading="lazy" alt="image-20210625104207071" src="http://phoenix-website.sz.iquantex.com/assets/images/phoenix-01-dfb516567767db8f47826f7ab454ea7b.png" width="953" height="619" class="img_ev3q"></p>
<p>用户在编写Phoenix代码时，需要定义Command和Event，Phoenix是利用EventSouring保障聚合根对象的状态持久性的，所以需要遵守一定的Phoenix开发规范。下面为Phoenix一个聚合根的示例代码:</p>
<p>可以看到，没有任何关于数据库操作的事情，当然也不需要再设计表结构，你接到需求后: 抽象需求 -&gt; 设计对象 -&gt; 编写代码 -&gt; 单元测试 -&gt; done。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token annotation punctuation" style="color:#393A34">@Slf4j</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token annotation punctuation" style="color:#393A34">@Data</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token annotation punctuation" style="color:#393A34">@EntityAggregateAnnotation</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">aggregateRootType </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"Hello"</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">class</span><span class="token plain"> </span><span class="token class-name">HelloAggregate</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">implements</span><span class="token plain"> </span><span class="token class-name">Serializable</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">static</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">final</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">long</span><span class="token plain"> serialVersionUID </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-</span><span class="token number" style="color:#36acaa">1L</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">   * 状态: 计数器</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">   */</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">long</span><span class="token plain"> num</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">   * 处理hello指令,产生HelloEvent</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">   *</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">   * @param cmd hello 指令</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">   * @return 处理结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">   */</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token annotation punctuation" style="color:#393A34">@CommandHandler</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">aggregateRootId </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"helloId"</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token class-name">ActReturn</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">act</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name">HelloCmd</span><span class="token plain"> cmd</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> </span><span class="token class-name">ActReturn</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">builder</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">retCode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name">RetCode</span><span class="token punctuation" style="color:#393A34">.</span><span class="token constant" style="color:#36acaa">SUCCESS</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">retMessage</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">"Hello World Phoenix "</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> cmd</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">getHelloId</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"..."</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">event</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">new</span><span class="token plain"> </span><span class="token class-name">HelloEvent</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">cmd</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">getHelloId</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">build</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">   * 处理helloEvent</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">   *</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">   * @param event hello事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">   */</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">on</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name">HelloEvent</span><span class="token plain"> event</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    num</span><span class="token operator" style="color:#393A34">++</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    log</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">info</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">"Phoenix State: {}"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> num</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>除此之外，Phoenix还提供了很多非功能特性，为了直观的做对比，我重新引用上面非功能需求分析的表格，从Phoenix的角度上分析如何降低用户使用门槛。</p>
<table><thead><tr><th>非功能需求</th><th>常见实现方式</th><th>Phoenix实现方式</th><th>Phoenix使用门槛</th></tr></thead><tbody><tr><td>事务保障</td><td>本地事务保障可以依赖关系型数据库来完成，借助ORM框架可以比较方便的操作数据库</td><td>Phoenix中的聚合根可以保障ACID，并且完全不需要用户考虑与数据的访问</td><td>低</td></tr><tr><td>高可用</td><td>在一个系统中，高可用至关重要，一般高可用要根据所用技术和所依赖的中间件做对应的设计。比如，可以使用RPC框架多点部署，然后客户端通过负载均衡来达到高可用</td><td>Phoenix集群可以互相感知，对故障节点做剔除，其他节点可以分担故障节点的请求，整个过程对用户是透明的。Phoenix可以做到秒级切换和恢复</td><td>低</td></tr><tr><td>接口幂等</td><td>用户可能发送同样的业务请求，在后端需要对该请求做接口幂等，一般会依赖数据库唯一索引，识别用户主键ID来做，但是为了满足幂等，表结构设计会增加一些额外要素</td><td>对于聚合根对象接收的命令，用户可以简单通过配置的指定命令中的成员来形成幂等主键，Phoenix可以保障同一个幂等ID的请求只会完成一次</td><td>低</td></tr><tr><td>扩缩容</td><td>扩容缩容是一件复杂的事情，虽然应用层是无状态可以容易做到，但是却把难点抛到了数据库，数据库的扩缩容不仅仅要涉及到分库分表(业务上拆分)，数据迁移，引入中间层（比如Mycat）等等。需要重点强调的是，在复杂业务场景，如何做分表是一件特别麻烦的事情，和业务的拆分息息相关</td><td>Phoenix可以方便的增加节点来分担集群的工作负载，对于依赖的数据库，由于Phoenix是在存储事件，扩缩容很容易（可以参考<a href="https://phoenix.iquantex.com/docs/phoenix-2.x/phoenix-test/elasticity-test" target="_blank" rel="noopener noreferrer">官方文档理解</a>）</td><td>中</td></tr><tr><td>高并发</td><td>设计高并发的系统首要是寻找并发粒度，有时候设计不完善的情况下，业务的并发粒度很难寻找，会导致各种行锁，表锁，甚至分布式锁，锁来锁去，也是个比较头疼的地方</td><td>Phoenix采用Actor的思想，要求用户设计初期就设计好并发粒度，然后再Actor内部不用在担心并发安全问题。目前Phoenix基础性能报告可以做到10W/S的TPS</td><td>中</td></tr><tr><td>分布式事务</td><td>业务横向拆分(分库)，纵向拆分(服务化)后，都会带来一些分布式事务的问题，可以利用比如seata的中间件解决，但也需要对业务的一致性和隔离性做一定取舍</td><td>Phoenix原生提供分布式事务组件，可以方便的让用户进行TCC,SAGA模式的事务编程</td><td>中</td></tr><tr><td>业务监控</td><td>系统运维人员希望对业务执行情况做实时监控，一般为了不耦合业务，会从数据库中反向解析形成另一套系统去做，通过实时分析计算技术去完成</td><td>得益于Phoenix事件驱动的思想，可以很方便的发布某个聚合根中内的所有事件到分析性数据库(Elasticsearch)然后配合phoenix的grafana视图，用户可以灵活的配置业务监控指标</td><td>低</td></tr><tr><td>可扩展性</td><td>有时候作为核心业务系统，其他系统希望接收该系统的行为做二次数据加工分析，那就对该系统的扩展性要求比较高。有些系统会在service层抓取动作，投递给MQ，有些系统则直接反向解析数据库日志。并且如果对时序要求较高时，也是比较难以处理的地方</td><td>同样，扩展性也是Phoenix的重要特性，事件可以原生的做发布(聚合根对象保证顺序)，其他系统就可以很方便的接收Phoenix产生的事件，做二次业务系统开发</td><td>低</td></tr></tbody></table>
<p>关于Phoenix更多介绍和特性，可以参考<a href="https://phoenix.iquantex.com/" target="_blank" rel="noopener noreferrer">官方文档</a>。</p>
<p>如果你的业务场景足够复杂，需要DDD + 充血模型的编程模式时，可以考虑使用Phoenix，Phoenix不仅提供友好的编程方式，而且还帮你解决很多非功能性问题。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-scene#%E6%80%BB%E7%BB%93" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h2>
<p>该篇介绍了贫血模型和充血模型，又介绍了Phoenix是如何友好的支持充血模型，并且phoenix做了大量的工作来帮用户解决了很多非功能性问题。</p>
<p>充血模型是一个编程思想，无论你用什么框架，都值得推荐！</p>]]></content:encoded>
            <category>phoenix</category>
            <category>stateful</category>
        </item>
        <item>
            <title><![CDATA[Phoenix 混沌测试实践]]></title>
            <link>http://phoenix-website.sz.iquantex.com/blog/phoenix-openchaos</link>
            <guid>http://phoenix-website.sz.iquantex.com/blog/phoenix-openchaos</guid>
            <pubDate>Thu, 24 Jun 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[本文将分享Phoenix在使用openchaos 进行混沌测试的实践]]></description>
            <content:encoded><![CDATA[<blockquote>
<p>本文将分享Phoenix在使用<a href="https://github.com/openmessaging/openchaos" target="_blank" rel="noopener noreferrer">openchaos</a> 进行混沌测试的实践</p>
</blockquote>
<!-- -->
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="一为什么需要混沌测试">一、为什么需要混沌测试？<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-openchaos#%E4%B8%80%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B7%B7%E6%B2%8C%E6%B5%8B%E8%AF%95" class="hash-link" aria-label="一、为什么需要混沌测试？的直接链接" title="一、为什么需要混沌测试？的直接链接">​</a></h2>
<p>随着计算机技术的发展，系统架构从集中式演进到分布式。分布式系统相对于单台机器来说提供了更好的可扩展性，容错性以及更低的延迟，但在单台计算机上运行软件和分布式系统上运行软件却有着根本的区别，其中一点便是单台计算机上运行软件，错误是可预测的。当硬件没有故障时，运行在单台计算机的软件总是产生同样的结果；而硬件如果出现问题，那么后果往往是整个系统的故障。因此，对于单体系统来说，要么功能完好且正确，要么完全失效，而不是介于两者之间。</p>
<p>而分布式系统则复杂的多。分布式系统涉及到多个节点和网络，因而存在部分失效的问题。分布式系统中不可靠的网络会导致数据包可能会丢失或任意延迟，不可靠的时钟导致某节点可能会与其他节点不同步 ，甚至一个节点上的进程可能会在任意时候暂停一段相当长的时间（比如由于垃圾收集器导致）而被宣告死亡，这些都给分布式系统带来了不确定性和不可预测性。事实上，这些问题在分布式系统中是无法避免的，就像著名的 CAP 理论中提出的，P（网络分区）是永远存在的，而不是可选的。</p>
<p>既然分布式系统中故障是无法避免的，那么处理故障最简单的方法便是让整个服务失效，让应用“正确地死去”，但这并不是所有应用都能接受。故障转移企图解决该问题，当故障发生时将其中一个从库提升为主库，使新主库仍然对外提供服务。但是主从数据不一致、脑裂等问题可能会让应用“错误地活着”。代码托管网站 Github 在一场事故中，就因为一个过时的 MySQL 从库被提升为主库 ，造成 MySQL 和 Redis 中数据产生不一致，最后导致一些私有数据泄漏到错误的用户手中 。为了减轻故障带来的影响，我们需要通过某种手段来确保数据的一致性，而如何验证大规模分布式系统在故障下依然正确和稳定（可靠性）成为了新的难题。</p>
<p>目前比较常用的有如下框架：</p>
<table><thead><tr><th>框架名称</th><th>支持平台</th><th>支持自动部署被测试服务</th><th>故障类型是否丰富</th><th>可视化界面</th><th>是否支持断言</th></tr></thead><tbody><tr><td>Chaos Mesh</td><td>Kubernetes</td><td>不支持</td><td>丰富</td><td>有</td><td>否</td></tr><tr><td>chaosblade</td><td>Docker、Kubernetes、OS</td><td>不支持</td><td>丰富</td><td>否</td><td>否</td></tr><tr><td>jepsen</td><td>Docker、OS</td><td>支持</td><td>丰富</td><td>否</td><td>是</td></tr><tr><td>openchaos</td><td>Docker、OS</td><td>支持</td><td>丰富</td><td>否</td><td>是</td></tr></tbody></table>
<p>准确的来说，像<strong>Chaos Mesh</strong>和<strong>openchaos</strong>的定位是不太相同的，<strong>Chaos Mesh</strong>主要提供比较完整的混沌实验故障注入的手段，而<strong>Openchaos</strong>则是需要针对某些类型中间件做固定Module运行，同时提供故障注入和结果校验的手段（比如Cache Module, QueueModule等）。<strong>Phoenix</strong>作为框架来说很适合<strong>openchaos</strong>这种轻量级，可扩展度高、支持结果校验的测试框架。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="二openchaos框架介绍">二、openchaos框架介绍<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-openchaos#%E4%BA%8Copenchaos%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D" class="hash-link" aria-label="二、openchaos框架介绍的直接链接" title="二、openchaos框架介绍的直接链接">​</a></h2>
<p>openchaos是openmessage组织下开源的一款混沌测试框架，主要用来测试各种开源分布式系统的可靠性、可用性和恢复能力。目前已经支持的有RocketMQ、Kafka、Dledger等。Openchaos可以基于用户的扩展一键发布运行所测试的服务，并且支持各种手段故障的注入机制，比如网络分区，进程崩溃，CPU超载等。另一方面还提供了各种校验模型，Cache，Queue来检测故障下是否还能满足预期。下面图中展示了Dledger在Openchaos中运行时的架构图。</p>
<p><img loading="lazy" alt="image-20210625104207071" src="http://phoenix-website.sz.iquantex.com/assets/images/001-06b125766f5e46c3854d6e2e6a838134.png" width="1068" height="658" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="三phoenix在openchaos的实践">三、Phoenix在Openchaos的实践<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-openchaos#%E4%B8%89phoenix%E5%9C%A8openchaos%E7%9A%84%E5%AE%9E%E8%B7%B5" class="hash-link" aria-label="三、Phoenix在Openchaos的实践的直接链接" title="三、Phoenix在Openchaos的实践的直接链接">​</a></h2>
<p><a href="https://phoenix.iquantex.com/docs/introduce" target="_blank" rel="noopener noreferrer">Phoenix</a>是一款有状态分布式计算框架，其提供以DDD中聚合根为概念的编程模型，可以帮助用户构建有状态的分布式服务。Phoenix依赖MQ通信和数据库存储事件。Phoenix可以保证MQ中数据精确一次消息语义（Exactly-once-semantics），这很适合Openchaos的Cache模型测试。</p>
<p><img loading="lazy" alt="image-20210625104207071" src="http://phoenix-website.sz.iquantex.com/assets/images/002-a7cc0d6d80d6b9b27c49f347da884548.png" width="1136" height="784" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="31-phoenix-openchaos-cache-module-测试">3.1 Phoenix Openchaos Cache Module 测试<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-openchaos#31-phoenix-openchaos-cache-module-%E6%B5%8B%E8%AF%95" class="hash-link" aria-label="3.1 Phoenix Openchaos Cache Module 测试的直接链接" title="3.1 Phoenix Openchaos Cache Module 测试的直接链接">​</a></h3>
<p>Openchaos运行时可以指定运行CacheModule，Cache测试分为两阶段，第一阶段由不同的客户端调用Cache API接口并发的向待测试集群添加不同的数据（每个客户端的key是相同的），中间会进行故障注入。Phoenix实现了其API，并实现了负责Key-Value存储的聚合根。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">    *  key始终是唯一的，每次put都是给key下面增加元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">    */</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token class-name">InvokeResult</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">put</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name">Optional</span><span class="token generics punctuation" style="color:#393A34">&lt;</span><span class="token generics class-name">String</span><span class="token generics punctuation" style="color:#393A34">&gt;</span><span class="token plain"> key</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">String</span><span class="token plain"> value</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">     * 获取这个key下所有的value（前面put进去的），在测试结束时调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">     */</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token class-name">List</span><span class="token generics punctuation" style="color:#393A34">&lt;</span><span class="token generics class-name">String</span><span class="token generics punctuation" style="color:#393A34">&gt;</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">getAll</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name">Optional</span><span class="token generics punctuation" style="color:#393A34">&lt;</span><span class="token generics class-name">String</span><span class="token generics punctuation" style="color:#393A34">&gt;</span><span class="token plain"> key</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>第二阶段，Opencahos会向待测试集群一次性读取结果集，最后验证每一个添加的元素都在最终结果集当中，Openchaos会把调用过程以及结果输出以下信息，根据Phoenix的Exactly-once-semantics语义，Phoenix可以通过判断 <code>putInvokeCount == getSuccessCount</code>来校验结果是否符合预期。</p>
<p>在实际测试过程中，我们开启了10个客户端并发的向待测试的Phoenix连续添加不重复的数字，中间会引入特定故障，比如随机杀死节点，非对称网络分区等。故障引入时间是60S，60S正常，60S故障，一直循环，整个过程持续300S。故障注入方面，我们测试以下几种故障注入：</p>
<ol>
<li>minor-kill模拟随机杀节点故障测试</li>
<li>fixed-partition非对称网络分区测试</li>
<li>OOM，CPU吃满等慢节点测试（ongoing）</li>
</ol>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">---</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">isValid: false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name: "CacheTestResult"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">putInvokeCount: 4725</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">putSuccessCount: 4542</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">getSuccessCount: 4725</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lostValueCount: 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lostValues: []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pass: true</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>可以看到10个客户端一共调用4725次，其中直接返回成功的有4542次（网络超时），最终调用结果集查询是4725次，公式验证通过<code>getSuccessCount==putInvokeCount</code>最终输出<code>pass: true</code>。</p>
<p>Openchaos支持输出图表更好的分析测试过程中的表现情况，Phoenix Cache Module测试操作情况和延时如下图所示。</p>
<p><img loading="lazy" alt="image-20210625104207071" src="http://phoenix-website.sz.iquantex.com/assets/images/003-6a41249ad28051e8e2797881794eaee9.png" width="851" height="639" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="32-phoenix-openchaos-bank-module-测试">3.2 Phoenix Openchaos Bank Module 测试<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-openchaos#32-phoenix-openchaos-bank-module-%E6%B5%8B%E8%AF%95" class="hash-link" aria-label="3.2 Phoenix Openchaos Bank Module 测试的直接链接" title="3.2 Phoenix Openchaos Bank Module 测试的直接链接">​</a></h3>
<p>Phoenix提供了分布式事务组件来解决跨聚合根处理的一致性问题。我们提供了银行转账的案例，在没有使用Openchaos之前，我们可以手动的发起N个账户的随机转账，最终校验账户总额不变来验证事务的可靠性。</p>
<p>得益于Openchaos提供灵活扩展的API，我们扩展了Openchaos新的模型：bank module，bank module可以更好的验证phoenix的分布式事务模块的可靠性和一致性。</p>
<p>第一阶段Openchaos会通过N个客户端发起对M个账户的随机转账随机金额，调用transfer api，同样中间也会引入故障注入。第二阶段Openchaos会发起所有账户的余额查询，每个账户初始金额是固定的（100），最终校验<code>所有余额汇总 == 100 * M</code></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">     * transfer account amt</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">     * @param outAccount</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">     * @param inAccount</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">     * @param amt</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">     */</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token class-name">InvokeResult</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">transfer</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name">String</span><span class="token plain"> outAccount</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">String</span><span class="token plain"> inAccount</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> amt</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">     * get all account amt</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">     * @param accounts</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">     */</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token class-name">List</span><span class="token generics punctuation" style="color:#393A34">&lt;</span><span class="token generics class-name">Integer</span><span class="token generics punctuation" style="color:#393A34">&gt;</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">getAllAmt</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name">List</span><span class="token generics punctuation" style="color:#393A34">&lt;</span><span class="token generics class-name">String</span><span class="token generics punctuation" style="color:#393A34">&gt;</span><span class="token plain"> accounts</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在实际测试过程中，我们开启了10个客户端并发的向待测试的Phoenix连续添加不重复的数字，中间会引入特定故障，比如随机杀死节点，非对称网络分区等。故障引入时间是60S，60S正常，60S故障，一直循环，整个过程持续300S。故障注入方面，我们同样测试以下几种故障注入：</p>
<ol>
<li>minor-kill模拟随机杀节点故障测试</li>
<li>fixed-partition非对称网络分区测试</li>
<li>OOM，CPU吃满等慢节点测试（ongoing）</li>
</ol>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">---</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">isValid: false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name: "BankTestResult"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">transferInvokeCount: 7245 # 请求转账册数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">transferSuccessCount: 6790 # 转账成功次数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">accountAmtTotal: 1000   # 银行总额</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>可以看到10个客户端一共调用7245次，其中直接返回成功的有6790次（网络超时），最终总金额为1000（10个账户，每个账户100），验证通过。</p>
<p>Openchaos支持输出图表更好的分析测试过程中的表现情况，Phoenix Cache Module测试操作情况和延时如下图所示。</p>
<p><img loading="lazy" alt="image-20210625114114480" src="http://phoenix-website.sz.iquantex.com/assets/images/005-9bcc1fbf110e45eb480beea09063983b.png" width="1079" height="842" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="33-phoenix-openchaos自动化混沌测试方案">3.3 Phoenix Openchaos自动化混沌测试方案<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-openchaos#33-phoenix-openchaos%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B7%B7%E6%B2%8C%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88" class="hash-link" aria-label="3.3 Phoenix Openchaos自动化混沌测试方案的直接链接" title="3.3 Phoenix Openchaos自动化混沌测试方案的直接链接">​</a></h3>
<p>有了以上两个模型的测试验证，Phoenix还希望构造一个混沌测试方案，即每次可以一键方便运行所有案例，并且支持校验功能。目前希望做到的</p>
<ol>
<li>每次发版前进行回归混沌测试案例，整个过程自动化</li>
<li>平时希望可以自动不断运行混沌测试案例，来测试Phoenix</li>
</ol>
<p>如下图所示，我们准备了一台专门负责跑混沌测试的机器，然后配置ci-job免密到这台机器之上，通过调用<code>start-openchaos.sh</code>脚本来完成所有案例的运行和校验</p>
<p><img loading="lazy" alt="image-20210625114114480" src="http://phoenix-website.sz.iquantex.com/assets/images/004-d7e4443485856c381c5edf3c96edf94d.png" width="1049" height="910" class="img_ev3q"></p>
<p><code>start-chaos.sh</code>脚本当中，一次会跑四次混沌案例</p>
<ol>
<li>cache模型的杀节点</li>
<li>cache模型的网络分区</li>
<li>bank模型的杀节点</li>
<li>bank模型的网络分区</li>
</ol>
<p>四次案例跑完之后，会统一展示并校验结果，并且可以再job的日志当中看到。</p>
<ol>
<li>cache模型校验: putInvokeSuccess == getSuccessCount</li>
<li>bank模型校验: allAmtTotal == 1000</li>
</ol>
<p>两种模型最终都会有一个 pass: true/false 值，然后start_openchaos.sh脚本会匹配这个值做校验决定是正常退出还是错误退出（决定ci是否通过）</p>
<p><img loading="lazy" alt="image-20210625114114480" src="http://phoenix-website.sz.iquantex.com/assets/images/006-d82f6c6ba399bc41a16c9acba1e4ee47.png" width="1322" height="1252" class="img_ev3q"></p>
<p>我们利用gitlab的自动调度机制，配置了每小时执行一次job，即简单了做到每天自动化的跑混沌测试场景，当后续案例更丰富之后，可以增加更多的场景自动化运行。并且后续每次发版前可以做到新版本的混沌测试，具体步骤如下:</p>
<ol>
<li>openchaos默认是使用的 master-SNAPSHOT 的phoenix版本。</li>
<li>phoenix每次发版前，把dev代码合并到master分支，触发更新master-SNAPSHOT版本</li>
<li>给openchaos打一个和pheonix同样的tag，自动触发进行上述4个案例跑的测试，（openchaos跑之前会重新build）（打同样tag的原因也是想保持一个版本一致性，如果openchaos也有变更可以和phoenix匹配起来。）</li>
<li>跑完结果通过job日志观察</li>
<li>并且把末尾的最终结果数据拷贝出来，放到每次发phoenix版本的那个issue上。</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="四总结展望">四、总结展望<a href="http://phoenix-website.sz.iquantex.com/blog/phoenix-openchaos#%E5%9B%9B%E6%80%BB%E7%BB%93%E5%B1%95%E6%9C%9B" class="hash-link" aria-label="四、总结展望的直接链接" title="四、总结展望的直接链接">​</a></h2>
<p>Phoenix经过Openchaos的实践，测试并修复了Phoenix很多BUG，最终可以通过cache和bank模型的可靠性验证。后续还希望支持更多的混沌案例，比如更复杂极端的网络情况，OOM，CPU负载高等等。</p>
<p>由于Phoenix运行时依赖于第三方存储和通信服务，目前的混沌测试还仅限于Phoenix本身，后续计划加上依赖的中间件一起进行混沌测试。</p>
<p>参考链接：</p>
<ol>
<li><a href="https://cloud.tencent.com/developer/news/481465" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/news/481465</a></li>
<li><a href="https://github.com/openmessaging/openchaos" target="_blank" rel="noopener noreferrer">https://github.com/openmessaging/openchaos</a></li>
</ol>]]></content:encoded>
            <category>phoenix</category>
            <category>openchaos</category>
        </item>
        <item>
            <title><![CDATA[Phoenix 特性解析]]></title>
            <link>http://phoenix-website.sz.iquantex.com/blog/features</link>
            <guid>http://phoenix-website.sz.iquantex.com/blog/features</guid>
            <pubDate>Fri, 05 Jun 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[本文解析phoenix的特性]]></description>
            <content:encoded><![CDATA[<blockquote>
<p>本文解析phoenix的特性</p>
</blockquote>
<!-- -->
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="编程模型">编程模型<a href="http://phoenix-website.sz.iquantex.com/blog/features#%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B" class="hash-link" aria-label="编程模型的直接链接" title="编程模型的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="actor模型">Actor模型<a href="http://phoenix-website.sz.iquantex.com/blog/features#actor%E6%A8%A1%E5%9E%8B" class="hash-link" aria-label="Actor模型的直接链接" title="Actor模型的直接链接">​</a></h3>
<p><img loading="lazy" alt="rpc" src="http://phoenix-website.sz.iquantex.com/assets/images/actor-636bf93c5bf7429f3d6ccfda529e2929.png" width="686" height="377" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="实体聚合根">实体聚合根<a href="http://phoenix-website.sz.iquantex.com/blog/features#%E5%AE%9E%E4%BD%93%E8%81%9A%E5%90%88%E6%A0%B9" class="hash-link" aria-label="实体聚合根的直接链接" title="实体聚合根的直接链接">​</a></h3>
<p><img loading="lazy" alt="rpc" src="http://phoenix-website.sz.iquantex.com/assets/images/entity-aggregate-9e67719ff1a780e0bbe1137c4554d884.png" width="993" height="443" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="事务聚合根">事务聚合根<a href="http://phoenix-website.sz.iquantex.com/blog/features#%E4%BA%8B%E5%8A%A1%E8%81%9A%E5%90%88%E6%A0%B9" class="hash-link" aria-label="事务聚合根的直接链接" title="事务聚合根的直接链接">​</a></h3>
<p><img loading="lazy" alt="rpc" src="http://phoenix-website.sz.iquantex.com/assets/images/transaction-aggregate-34038ebda2ff6dc5062ddba00e1432fd.png" width="1289" height="414" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="单元测试">单元测试<a href="http://phoenix-website.sz.iquantex.com/blog/features#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" class="hash-link" aria-label="单元测试的直接链接" title="单元测试的直接链接">​</a></h3>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * 划拨失败</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> */</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token annotation punctuation" style="color:#393A34">@Test</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">allocate_exceptFail</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	</span><span class="token class-name">EntityAggregateFixture</span><span class="token plain"> fixture </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">new</span><span class="token plain"> </span><span class="token class-name">EntityAggregateFixture</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	</span><span class="token comment" style="color:#999988;font-style:italic">// 向 A0 账户划拨 -1500 元，期待划拨失败</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	</span><span class="token class-name">AccountAllocateCmd</span><span class="token plain"> cmd </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">new</span><span class="token plain"> </span><span class="token class-name">AccountAllocateCmd</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">"A0"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-</span><span class="token number" style="color:#36acaa">1500</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	</span><span class="token comment" style="color:#999988;font-style:italic">// 断言</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	fixture</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">when</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">cmd</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">expectRetFailCode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">expectMessage</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name">AccountAllocateFailEvent</span><span class="token punctuation" style="color:#393A34">.</span><span class="token keyword" style="color:#00009f">class</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="通讯模型">通讯模型<a href="http://phoenix-website.sz.iquantex.com/blog/features#%E9%80%9A%E8%AE%AF%E6%A8%A1%E5%9E%8B" class="hash-link" aria-label="通讯模型的直接链接" title="通讯模型的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="请求-响应">请求-响应<a href="http://phoenix-website.sz.iquantex.com/blog/features#%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94" class="hash-link" aria-label="请求-响应的直接链接" title="请求-响应的直接链接">​</a></h3>
<p><img loading="lazy" alt="rpc" src="http://phoenix-website.sz.iquantex.com/assets/images/rpc-8fa44d8194379af873096e254f36be23.png" width="771" height="731" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="非回复">非回复<a href="http://phoenix-website.sz.iquantex.com/blog/features#%E9%9D%9E%E5%9B%9E%E5%A4%8D" class="hash-link" aria-label="非回复的直接链接" title="非回复的直接链接">​</a></h3>
<p><img loading="lazy" alt="rpc-noreply" src="http://phoenix-website.sz.iquantex.com/assets/images/rpc-noreply-65b5259ca5c44923e5698fa0eff54507.png" width="919" height="950" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="主动订阅">主动订阅<a href="http://phoenix-website.sz.iquantex.com/blog/features#%E4%B8%BB%E5%8A%A8%E8%AE%A2%E9%98%85" class="hash-link" aria-label="主动订阅的直接链接" title="主动订阅的直接链接">​</a></h3>
<p><img loading="lazy" alt="subscribes" src="http://phoenix-website.sz.iquantex.com/assets/images/subscribes-7d9c8abff5bd69f93b10a774b8da4344.png" width="1094" height="732" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="调用其他服务">调用其他服务<a href="http://phoenix-website.sz.iquantex.com/blog/features#%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E6%9C%8D%E5%8A%A1" class="hash-link" aria-label="调用其他服务的直接链接" title="调用其他服务的直接链接">​</a></h2>
<p><img loading="lazy" alt="subscribes" src="http://phoenix-website.sz.iquantex.com/assets/images/spring-d9d300793f7ffda90a244af981ac0e9c.png" width="954" height="776" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="事件发布">事件发布<a href="http://phoenix-website.sz.iquantex.com/blog/features#%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83" class="hash-link" aria-label="事件发布的直接链接" title="事件发布的直接链接">​</a></h2>
<p><img loading="lazy" alt="subscribes" src="http://phoenix-website.sz.iquantex.com/assets/images/eventpublish-bf09504881b64e10e9d5c726700c24df.png" width="990" height="635" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="查询模型">查询模型<a href="http://phoenix-website.sz.iquantex.com/blog/features#%E6%9F%A5%E8%AF%A2%E6%A8%A1%E5%9E%8B" class="hash-link" aria-label="查询模型的直接链接" title="查询模型的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="query-model">Query-Model<a href="http://phoenix-website.sz.iquantex.com/blog/features#query-model" class="hash-link" aria-label="Query-Model的直接链接" title="Query-Model的直接链接">​</a></h3>
<p>最终一致性读
基于数据库query
<img loading="lazy" alt="subscribes" src="http://phoenix-website.sz.iquantex.com/assets/images/query-module-da94b624f1f120fa6fc2c6f4da86a0b2.png" width="949" height="647" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="querycommandhandler">QueryCommandHandler<a href="http://phoenix-website.sz.iquantex.com/blog/features#querycommandhandler" class="hash-link" aria-label="QueryCommandHandler的直接链接" title="QueryCommandHandler的直接链接">​</a></h3>
<p>线性一致性读
<img loading="lazy" alt="subscribes" src="http://phoenix-website.sz.iquantex.com/assets/images/query-rpc-1fff913b6a8543f9f6172e213b74b68e.png" width="1046" height="792" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="运行模型">运行模型<a href="http://phoenix-website.sz.iquantex.com/blog/features#%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%9E%8B" class="hash-link" aria-label="运行模型的直接链接" title="运行模型的直接链接">​</a></h2>
<ul>
<li>dataSharding</li>
<li>聚合根飘逸</li>
</ul>]]></content:encoded>
            <category>phoenix</category>
            <category>features</category>
        </item>
        <item>
            <title><![CDATA[Phoenix 是如何实现幂等的]]></title>
            <link>http://phoenix-website.sz.iquantex.com/blog/idempotent</link>
            <guid>http://phoenix-website.sz.iquantex.com/blog/idempotent</guid>
            <pubDate>Mon, 25 May 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[幂等：在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。]]></description>
            <content:encoded><![CDATA[<blockquote>
<p><strong>幂等</strong>：在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。</p>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="介绍">介绍<a href="http://phoenix-website.sz.iquantex.com/blog/idempotent#%E4%BB%8B%E7%BB%8D" class="hash-link" aria-label="介绍的直接链接" title="介绍的直接链接">​</a></h2>
<p><strong>Phoenix</strong>在执行<strong>act</strong>方法前都会对<strong>command message</strong>进行幂等判断，如果消息已处理则直接返回处理结果，不再执行<strong>act</strong>方法和<strong>on</strong>方法。</p>
<!-- -->
<p><img loading="lazy" alt="总体流程图" src="http://phoenix-website.sz.iquantex.com/assets/images/001-overall-a785bee8c3db6b49f9c00a96fdce175a.png" width="1638" height="679" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="幂等id">幂等ID<a href="http://phoenix-website.sz.iquantex.com/blog/idempotent#%E5%B9%82%E7%AD%89id" class="hash-link" aria-label="幂等ID的直接链接" title="幂等ID的直接链接">​</a></h2>
<p>可以在<code>@CommandHandler</code>注解中定义幂等字段，<strong>Phoenix</strong>会调用相应字段的<strong>get</strong>方法并拼接为一个幂等ID，如果为定义则<strong>Phoenix</strong>会生成一个<strong>UUID</strong>来用作幂等ID。如果获取幂等ID失败，将抛出异常事件。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="幂等判断">幂等判断<a href="http://phoenix-website.sz.iquantex.com/blog/idempotent#%E5%B9%82%E7%AD%89%E5%88%A4%E6%96%AD" class="hash-link" aria-label="幂等判断的直接链接" title="幂等判断的直接链接">​</a></h2>
<p><strong>Phoenix</strong>幂等逻辑包含两部分：<strong>内存幂等</strong>和<strong>数据库幂等</strong>，处理顺序为：</p>
<p><code>cmdMsg &gt;&gt; 内存幂等  &gt;&gt; 数据库幂等  &gt;&gt; act方法</code></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="内存幂等">内存幂等<a href="http://phoenix-website.sz.iquantex.com/blog/idempotent#%E5%86%85%E5%AD%98%E5%B9%82%E7%AD%89" class="hash-link" aria-label="内存幂等的直接链接" title="内存幂等的直接链接">​</a></h3>
<p>在<strong>Phoenix</strong>中维护了一个<code>LinkedHashMap</code>类型的幂等集合：<strong>key</strong>为幂等ID，<strong>value</strong>为结果事件。在执行内存幂等前会受先通过内存幂等集合来判断幂等，如果判断消息已处理过，则从幂等缓存中读取结果事件直接返回，否则执行后续操作。内存幂等集合大小可以通过参数进行配置，超过该大小的保存在幂等集合的消息将按照先进先出消息丢弃</p>
<ul>
<li>内存幂等集合大小配置</li>
</ul>
<p>内存幂等集合大小为聚合根级别，可以通过<code>@EntityAggregateAnnotation</code>的<code>idempotentSize</code>属性进行配置，**默认值:**1000</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="数据库幂等">数据库幂等<a href="http://phoenix-website.sz.iquantex.com/blog/idempotent#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%82%E7%AD%89" class="hash-link" aria-label="数据库幂等的直接链接" title="数据库幂等的直接链接">​</a></h3>
<p>数据库幂等在内存幂等之后，如果内存幂等判定为未处理，且消息为重试消息，则会根<code>aggregateId</code>（聚合id）和<code>idempotentId</code>（幂等id）查询数据库。</p>]]></content:encoded>
            <category>Idempotent</category>
            <category>IdempotentId</category>
        </item>
        <item>
            <title><![CDATA[Phoenix 通过GitLab管理开发流程技术分享]]></title>
            <link>http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow</link>
            <guid>http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow</guid>
            <pubDate>Tue, 07 Apr 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[本篇文章介绍了宽拓科技Phoenix组如何使用GitLab进行高效的远程开发协作。]]></description>
            <content:encoded><![CDATA[<blockquote>
<p>本篇文章介绍了宽拓科技Phoenix组如何使用GitLab进行高效的远程开发协作。</p>
</blockquote>
<!-- -->
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="开发流程介绍">开发流程介绍<a href="http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow#%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D" class="hash-link" aria-label="开发流程介绍的直接链接" title="开发流程介绍的直接链接">​</a></h2>
<p>总体流程分为Issue指定，开发，版本发布三个步骤。
<img loading="lazy" alt="总体流程图" src="http://phoenix-website.sz.iquantex.com/assets/images/010-%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE-4909b2ab89d3cf03ac9eab0121223b8d.png" width="1101" height="530" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="okr制定">OKR制定<a href="http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow#okr%E5%88%B6%E5%AE%9A" class="hash-link" aria-label="OKR制定的直接链接" title="OKR制定的直接链接">​</a></h3>
<p><img loading="lazy" alt="image" src="http://phoenix-website.sz.iquantex.com/assets/images/001-okr-77d063d4255123e0801372fd9eb73036.png" width="1039" height="773" class="img_ev3q">
创建一个新的OKR的时候，首先小组组长罗列出这个OKR中的主要目标，然后发起电话会议邀请组内成员一起讨论分析OKR的具体任务是那些</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="制定milestones">制定Milestones<a href="http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow#%E5%88%B6%E5%AE%9Amilestones" class="hash-link" aria-label="制定Milestones的直接链接" title="制定Milestones的直接链接">​</a></h3>
<p><img loading="lazy" alt="image" src="http://phoenix-website.sz.iquantex.com/assets/images/002-Milestones-a602576b3dc993976a9d3de041d2e461.png" width="1423" height="1006" class="img_ev3q">
根据OKR讨论出来的任务创建Milestones，用来关联OKR中讨论出来的任务，这样可以在Milestones面板很直观的看到当前任务的进度以及开发状态</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="issue整理">Issue整理<a href="http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow#issue%E6%95%B4%E7%90%86" class="hash-link" aria-label="Issue整理的直接链接" title="Issue整理的直接链接">​</a></h3>
<p>创建Milestones之后就可以根据Milestones来拆分出具体任务，拆分出来的Issue需要遵循一下规定:</p>
<ol>
<li>每个Issue都需要关联到对应的Milestones</li>
<li>Issue描述应尽可能详细，例如：完成Issue的目标，Issue的交付物都有哪些等等</li>
<li>可以根据Issue的描述来评估Issue工作量，以便之后对每个人工作的量化统计</li>
<li>刚创建的Issue应放在<strong>待准入</strong>面板中让其他同事一起来评估是否合理等，如果评估没有发现问题即可打上自己的RA标签（尽可能在Issue下的评论区进行讨论，这样同组的同事都可以看到，发现问题也可以及时补充）</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="任务开发">任务开发<a href="http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow#%E4%BB%BB%E5%8A%A1%E5%BC%80%E5%8F%91" class="hash-link" aria-label="任务开发的直接链接" title="任务开发的直接链接">​</a></h3>
<p><img loading="lazy" alt="image" src="http://phoenix-website.sz.iquantex.com/assets/images/003-issue-dfbb5fa0f1e16ee55281ae4ce7e4da25.png" width="1598" height="603" class="img_ev3q"></p>
<ol>
<li>在待认领面板中认领Issue</li>
<li>并且将Issue拖入<strong>Doing</strong>面板</li>
<li>认领的Issue需要在<strong>Assignee</strong>中设置为自己</li>
<li>设置<strong>Due date</strong>(Issue接完成截至日期)</li>
<li>进行开发测试或文档整理，如果任务是开发任务需要将<strong>Merge Requests</strong>关联到相关<code>Issue</code>，如果是文档任务需要将文档地址关联到<code>Issue</code>（在开发中遇到问题可以将问题提现到Issue中，或者拉上组内成员一起讨论）</li>
<li>任务完成后将<code>Issue</code>拖入<strong>待review</strong>面板</li>
<li>其他同事应主动去<code>review</code>其他人的任务，如果有建议或者问题及时在Issue上进行评论</li>
<li>review没有发现问题的话可以打上RR标签</li>
<li>当<strong>待review</strong>中的<code>Issue</code>的<code>RR</code>标签超过两个，可以将<code>Issue</code>拖入待关闭并且合并<code>Issue</code>中的代码</li>
<li>合并代码后环境测试没有问题机可彻底关闭<code>Issue</code></li>
</ol>
<p><img loading="lazy" alt="image" src="http://phoenix-website.sz.iquantex.com/assets/images/011-issue%E5%BC%80%E5%8F%91%E5%91%A8%E6%9C%9F-5f6d1f7e6b45d3f74c7e2a58b82ca494.png" width="1966" height="1244" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="集成测试">集成测试<a href="http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95" class="hash-link" aria-label="集成测试的直接链接" title="集成测试的直接链接">​</a></h3>
<p>OKR中的所有任务都开发完成，需要罗列出OKR关联所有变动的测试案例进行封板测试。封板测试案例：</p>
<p><img loading="lazy" alt="image" src="http://phoenix-website.sz.iquantex.com/assets/images/004-grableVer-a2cd11b39eb883b651df1e9f96458d06.png" width="807" height="1106" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="版本发布">版本发布<a href="http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow#%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83" class="hash-link" aria-label="版本发布的直接链接" title="版本发布��的直接链接">​</a></h3>
<p>全部测试完成即可升级相应项目版本，并制作相应tag（建议在tag中表明本次升级的所有变动点）</p>
<p><img loading="lazy" alt="tags" src="http://phoenix-website.sz.iquantex.com/assets/images/012-tags-c770265198f1c5fbc45a351609418531.png" width="1306" height="743" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="更新生产环境">更新生产环境<a href="http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow#%E6%9B%B4%E6%96%B0%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83" class="hash-link" aria-label="更新生产环境的直接链接" title="更新生产环境的直接链接">​</a></h3>
<p>phoenix集成了helm，当合并到master分支后即可在rancher应用商店页面直接升级</p>
<p><img loading="lazy" alt="rancher升级" src="http://phoenix-website.sz.iquantex.com/assets/images/013-rancher-cc62f5ca4a1eb0bb240106dae4c91756.png" width="1284" height="605" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow#%E6%80%BB%E7%BB%93" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h3>
<p>Phoenix组通过以上开发流程完成了高效、可视、线上化的从任务创建到版本升级整个任务的流程分配于协作。</p>
<ul>
<li>以上所有步骤全部遵循<a href="https://portal.iquantex.com/confluence/pages/viewpage.action?pageId=35816806" target="_blank" rel="noopener noreferrer">Gitflow</a>开发规定</li>
</ul>
<p><img loading="lazy" alt="image" src="http://phoenix-website.sz.iquantex.com/assets/images/005-gitflow-37d7c4c062090bd01a0014c0150376fe.png" width="1857" height="2500" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="gitlab功能介绍">GitLab功能介绍<a href="http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow#gitlab%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D" class="hash-link" aria-label="GitLab功能介绍的直接链接" title="GitLab功能介绍的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="标签介绍">标签介绍<a href="http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow#%E6%A0%87%E7%AD%BE%E4%BB%8B%E7%BB%8D" class="hash-link" aria-label="标签介绍的直接链接" title="标签介绍的直接链接">​</a></h3>
<ul>
<li><strong>公告:</strong> 可以存放一些公共信息 **例如：**OKR内容、环境信息、会议记录等</li>
<li><strong>讨论:</strong> 存放一些项目发展方向的讨论记录，项目整体设计等</li>
<li><strong>待准入:</strong> 用来存放新创建待其他同事检查的<code>Issue</code></li>
<li><strong>待认领:</strong> 存放检查通过的<code>Issue</code></li>
<li><strong>Doing:</strong> 存放正在开发的<code>Issue</code></li>
<li><strong>待review:</strong> 存放可以进行<code>review</code>的<code>Issue</code></li>
<li><strong>待关闭:</strong> 存放已经合并的，但是需要在环境上进行测试的Issue</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="面板配置">面板配置<a href="http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow#%E9%9D%A2%E6%9D%BF%E9%85%8D%E7%BD%AE" class="hash-link" aria-label="面板配置的直接链接" title="面板配置的直接链接">​</a></h3>
<ol>
<li>在<code>Issues-&gt;Labels</code>增加面板标签：<strong>待准入</strong>、<strong>待认领</strong>、<strong>Doing</strong>、<strong>待review</strong>、<strong>待关闭</strong>等标签</li>
</ol>
<p><img loading="lazy" alt="1585898814667" src="http://phoenix-website.sz.iquantex.com/assets/images/006-6904a4fe88931388d543205c482effff.png" width="2318" height="454" class="img_ev3q"></p>
<ol start="2">
<li>在<code>Issues-&gt;Board</code>中点击<strong>Add List</strong>，增加面板</li>
</ol>
<p><img loading="lazy" alt="1585899041726" src="http://phoenix-website.sz.iquantex.com/assets/images/007-f35e34a86895e65eeaa53aad06c379d3.png" width="2536" height="699" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="标签功能介绍">标签功能介绍<a href="http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow#%E6%A0%87%E7%AD%BE%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D" class="hash-link" aria-label="标签功能介绍的直接链接" title="标签功能介绍的直接链接">​</a></h3>
<ul>
<li>
<p><strong>RA标签:<strong>待准入检查没问题后打入</strong>RA:张三</strong>的标签（只能使用自己的标签）</p>
</li>
<li>
<p><strong>RD标签:<strong>如果</strong>Issue</strong>由多个同事完成，需要在<strong>Issue</strong>中打入一起来完成<strong>Issue</strong>的同事，同事在Issue中说明时间分配</p>
</li>
<li>
<p><strong>RR标签:</strong> <strong>待review</strong>检查没问题后打入</p>
</li>
<li>
<p><strong>时间标签:</strong> 主要用来衡量一个Issue的工作量，这里可以是完成该Issue需要的时间。</p>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="标签配置">标签配置<a href="http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow#%E6%A0%87%E7%AD%BE%E9%85%8D%E7%BD%AE" class="hash-link" aria-label="标签配置的直接链接" title="标签配置的直接链接">​</a></h3>
<ol>
<li>进入<strong>Issues -&gt; Labels</strong>进行配置</li>
</ol>
<p><img loading="lazy" alt="1585899469004" src="http://phoenix-website.sz.iquantex.com/assets/images/008-2500fbd556da422ec96c1808b2f52d27.png" width="2154" height="684" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="其他功能介绍">其他功能介绍<a href="http://phoenix-website.sz.iquantex.com/blog/GitLab-workflow#%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D" class="hash-link" aria-label="其他功能介绍的直接链接" title="其他功能介绍的直接链接">​</a></h3>
<ul>
<li><strong>Due date</strong> 截止时间，指认领Issue后Issue最后的完成时间</li>
<li><strong>Milestones</strong> GitLab中的里程碑是一种跟踪问题并合并为在特定时期内实现更广泛目标而创建的请求的方法。</li>
</ul>
<p><img loading="lazy" alt="1585899715828" src="http://phoenix-website.sz.iquantex.com/assets/images/009-44f3908689923c10dac5c8be93bc7c78.png" width="2091" height="592" class="img_ev3q"></p>
<ul>
<li><code>Merge Requests</code> 如何关联Issue</li>
</ul>
<ol>
<li>同一个group同一个project：在<code>Merge Requests</code>的<code>Description</code>中填入<code>#+ [Issue编号]</code>的方式关联</li>
<li>同一个group不同project：在<code>Merge Requests</code>的<code>Description</code>中填入<code>[project名称]+#+[Issue编号]</code>的方式关联</li>
<li>不同group：在<code>Merge Requests</code>的<code>Description</code>中填入<code>[group名称]+/+[project名称]+#+[Issue编号]</code>关联</li>
</ol>
<p><em>还有一种简单的方法关联Issue，在<code>Merge Requests</code>的<code>Description</code>中填入对应Issue的url即可</em></p>
<h1>链接</h1>
<ul>
<li><a href="https://docs.gitlab.com/ee/user/project/labels.html" target="_blank" rel="noopener noreferrer">GitLab Labels官方文档</a></li>
<li><a href="https://docs.gitlab.com/ee/user/project/milestones/" target="_blank" rel="noopener noreferrer">GitLab Milestones官方文档</a></li>
<li><a href="https://gitlab.iquantex.com/help/ci/README.md" target="_blank" rel="noopener noreferrer">GitLab ci/cd官方文档</a></li>
</ul>]]></content:encoded>
            <category>Phoenix</category>
            <category>GitLab</category>
        </item>
        <item>
            <title><![CDATA[RocketMQ在Phoenix框架中的应用与实践]]></title>
            <link>http://phoenix-website.sz.iquantex.com/blog/rocketmq-in-phoenix</link>
            <guid>http://phoenix-website.sz.iquantex.com/blog/rocketmq-in-phoenix</guid>
            <pubDate>Thu, 16 Jan 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[感谢RocketMQ官微采稿]]></description>
            <content:encoded><![CDATA[<p><strong>感谢<a href="https://mp.weixin.qq.com/s?__biz=MzIxODM2NTQ3OQ==&amp;mid=2247484214&amp;idx=1&amp;sn=d17f889cd8ddefe65fb4dae8e95c1354&amp;chksm=97eae87ea09d6168a3a13ea4266e2c0a9cbf0c4d2d67cb16a83a822e9f6b8f8281be1c23ff8c&amp;scene=27#wechat_redirect" target="_blank" rel="noopener noreferrer">RocketMQ官微</a>采稿</strong></p>
<blockquote>
<p>摘要：Phoenix是宽拓科技架构团队研发的内存计算框架，借鉴了LMAX的架构思路，采用CQRS和EventSouring理念打造。本文简单介绍Phoenix，以及RocketMQ在Phoenix中的应用与实践。 注：该Phoenix不是Apache开源的那个Phoenix。</p>
</blockquote>
<p>{<strong>truncate</strong>}</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="行业背景">行业背景<a href="http://phoenix-website.sz.iquantex.com/blog/rocketmq-in-phoenix#%E8%A1%8C%E4%B8%9A%E8%83%8C%E6%99%AF" class="hash-link" aria-label="行业背景的直接链接" title="行业背景的直接链接">​</a></h2>
<p>在金融资管投资交易领域，业务场景复杂，如在交易处理场景中，存在事前的风控头寸控制需求，导致交易事件必须串行处理，无法并发，且单次交易事件处理中，存在高密度的复杂业务逻辑计算且依赖数据范围广，所以系统的性能问题非常突出。</p>
<p>目前业内一般基于关系型数据库来处理单个交易事件，会存在复杂SQL运算逻辑和多次IO读取数据，因此很难做到低延迟。并且由于业务逻辑比较复杂，经常陷入与表模型纠缠当中。</p>
<p>因为交易事件必须串行处理，所以基于SpringCloud/Dubbo这类分布式框架，并不能享受到横向扩容带来的计算能力提升的好处，反而在多点部署的时候需要引入全局锁来做好并发保护，增加了业务实现的复杂度。</p>
<p>基于此我们在借鉴了英国外汇交易中心的LMAX架构基础上，结合CQRS + EventSouring理念，落地了一套基于Java的内存计算框架Phoenix。目标是要把复杂的业务逻辑拿到内存中计算，摆脱对关系型数据库的依赖，结合DDD设计思路，让业务开发人员真正面向对象编程，大大降低单个事件的处理延时，通过低延迟获取高吞吐回报。同时利用单线程模式，避免了并发场景，降低了编程复杂度。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="phoniex介绍">Phoniex介绍<a href="http://phoenix-website.sz.iquantex.com/blog/rocketmq-in-phoenix#phoniex%E4%BB%8B%E7%BB%8D" class="hash-link" aria-label="Phoniex介绍的直接链接" title="Phoniex介绍的直接链接">​</a></h2>
<p>Phoenix是对CQRS + EventSouring理念落地的JAVA开发框架，围绕Phoenix开发框架打造了一套开发运维平台。Phoenix框架具有如下特性： ln-Memory、支持分布式事务（SAGA）、微服务、单线程、支持同步/异步调用。 在开发运维平台上提供，内存查询/修改、快照管理，事件编排，调用链跟踪、实时监控、个性化业务指标监控、性能指标统计等。目前已经在生产中使用</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="架构图">架构图<a href="http://phoenix-website.sz.iquantex.com/blog/rocketmq-in-phoenix#%E6%9E%B6%E6%9E%84%E5%9B%BE" class="hash-link" aria-label="架构图的直接链接" title="架构图的直接链接">​</a></h3>
<p><img loading="lazy" alt="image-phoenix" src="http://phoenix-website.sz.iquantex.com/assets/images/jiagou-fce54f0a4c82f0cd6fe5f3a4b89bd7bf.jpg" width="1614" height="922" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="概念术语">概念术语<a href="http://phoenix-website.sz.iquantex.com/blog/rocketmq-in-phoenix#%E6%A6%82%E5%BF%B5%E6%9C%AF%E8%AF%AD" class="hash-link" aria-label="概念术语的直接链接" title="概念术语的直接链接">​</a></h3>
<p><strong>Command</strong>：由CServer定义，表示请求的入参。</p>
<p><strong>Event</strong> ：由CServer定义，表示领域内已发生的事件。</p>
<p><strong>CServer</strong>： 业务处理服务，采用内存保存数据状态。收到请求Command后，通过业务处理逻辑，产⽣结果Event，然后Event再驱动内存数据状态改变。当服务重启后， 利用EventSouring来恢复内存数据。</p>
<p><strong>QServer</strong>：订阅CServer产生的领域Event，加工后得到查询端的数据模型。 如可以持久化到关系数据库供查询，又或者持久化到内存数据库供高速查询。</p>
<p><strong>Saga</strong>：负责分布式事务协调，接收Event，产生Command， 协调各个CServer一起工作，共同完成事务。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="rocketmq和phoenix">RocketMQ和Phoenix<a href="http://phoenix-website.sz.iquantex.com/blog/rocketmq-in-phoenix#rocketmq%E5%92%8Cphoenix" class="hash-link" aria-label="RocketMQ和Phoenix的直接链接" title="RocketMQ和Phoenix的直接链接">​</a></h3>
<p>​上面简单介绍了行业背景和Phoenix，关于CQRS和EventSouring相关理念，这里不多阐述，大家可以上网搜索相关资料来理解Phoenix。回到与RocketMQ相关，在Phoenix框架里RocketMQ承担了什么角色？我们为什么选用RocketMQ，这里要从EventSouring说起。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="rocketmq和eventsouring">RocketMQ和EventSouring<a href="http://phoenix-website.sz.iquantex.com/blog/rocketmq-in-phoenix#rocketmq%E5%92%8Ceventsouring" class="hash-link" aria-label="RocketMQ和EventSouring的直接链接" title="RocketMQ和EventSouring的直接链接">​</a></h3>
<p>​Phoenix应用基于的内存来计算，最大的问题就是进程重启或Crash，内存数据全部丢失。而EventSourcing就是用于进程重启后恢复内存数据状态的。</p>
<p>​举例：有一个Java对象account，ID为001，当前状态：余额10元。假设是经过如下三个操作达到了该状态：</p>
<ul>
<li>Account account = new Account(001, 0);  — 初建对象</li>
<li>account.amt = account.amt + 14; — 转入14元</li>
<li>account.amt = account.amt - 4; — 转出4元</li>
</ul>
<p>如果进程重启，根据EventSouring思想，我们可以重播操作1、2、3来恢复重启前的Account状态。</p>
<p>对于Phoenix，我们做了如下思考：</p>
<p><strong>思考1</strong>： Phoenix应用通过领域Event回溯可以重建内存状态，那领域Event该怎么存储？</p>
<p>首先回溯的时一定要确保领域Event有序且不漏，这里我们选择了RocketMQ来存储领域Event:</p>
<ol>
<li>RocketMQ中同步刷盘机制，可以保证消息不丢。</li>
<li>topic的单queue模式，可以保证消息有序存储，有序消费。</li>
<li>RocketMQ是一个基于文件持久化的高性能MQ，支持重复消费。</li>
<li>RocketMQ本身经历过阿里双12的考验，更适合金融场景。</li>
</ol>
<p><strong>思考2</strong>：对比采用数据库保存数据状态，Phoenix采用了RocketMQ来持久化领域Event，两者都存在数据持久化动作，那么两者性能对比如何？我们来分析一下一个账户的转入操作。</p>
<p>使用数据库的处理方式：</p>
<ol>
<li>根据账户ID从数据库中取出账户信息，开启事务且加锁。</li>
<li>程序进行账户的加钱操作，写会数据库，提交事务(写数据库还涉及建立索引，写binlog，redolog等)。</li>
</ol>
<p>使用Phoenix的处理方式：</p>
<ol>
<li>Phoenix应用从RocketMQ中读取Command，完成消息反序列化。</li>
<li>路由Command到具体的聚合根对象，调用处理函数act，产生领域Event，Event驱动内存数据状态改变。</li>
<li>将Event序列化后publish到RocketMQ。</li>
</ol>
<p><img loading="lazy" alt="image-phoenix-handle" src="http://phoenix-website.sz.iquantex.com/assets/images/phoenix-handle-904651b229198694fb6090d4634f782b.jpg" width="1614" height="1364" class="img_ev3q"></p>
<p>​以上3个步骤，采用disruptor，以流水线方式处理。处理过程，是采用先修改内存状态，再持久化Event到RocketMQ。之所以可以这样设计，是因为Event的发布和存储是在一个事务中完成的。</p>
<p>​显然，存储状态需要进行两次IO操作，并且如果是一个新增操作，建立索引等耗时都是要考虑在内的。而RocketMQ存储领域Event时，只需要把Event内容追加到commitlog文件尾（1~2ms），配合着GroupCommit技术，可以做到非常高的吞吐量，效率更高。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="rocketmq下的phoenix框架性能">RocketMQ下的Phoenix框架性能<a href="http://phoenix-website.sz.iquantex.com/blog/rocketmq-in-phoenix#rocketmq%E4%B8%8B%E7%9A%84phoenix%E6%A1%86%E6%9E%B6%E6%80%A7%E8%83%BD" class="hash-link" aria-label="RocketMQ下的Phoenix框架性能的直接链接" title="RocketMQ下的Phoenix框架性能的直接链接">​</a></h3>
<p>​单个CServer，在PC机（X99平台 + Intel(R) Core(TM) i7-5820K CPU @ 3.30GHz + SSD) 下的采用echo测试结果：TPS=2w/s, latency = 1~2ms</p>
<p>​虽然这个TPS对比Dubbo这类的框架下单服务TPS并不算高， 但得益于内存计算，回到开篇提到的复杂业务逻辑计算下，单个交易事件的业务处理耗时能做到ms下，TPS可以达到 k/s 级别。 端到端延时在毫秒级。这在基于数据库的模式下是很难做到的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="rocketmq的消息存储问题">RocketMQ的消息存储问题<a href="http://phoenix-website.sz.iquantex.com/blog/rocketmq-in-phoenix#rocketmq%E7%9A%84%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E9%97%AE%E9%A2%98" class="hash-link" aria-label="RocketMQ的消息存储问题的直接链接" title="RocketMQ的消息存储问题的直接链接">​</a></h3>
<p>​根据EventSouring的描述，理想情况下我们是需要RocketMQ永不清理消息，可以通过调整broker的配置设置<code>fileReservedTime=99999999999</code>消息时间。这里RocketMQ没有提供直接关掉清理策略开关，其中一条清理策略是，如果磁盘空间达到85%以上，RocketMQ无论消息过期都会清理消息。</p>
<p>​在实际生产场景中，我们并不会要求RocketMQ永不清理消息。因为CServer应用会采用快照功能，每天都会定时把内存状态和当时Queue的Offset存储到数据库中（存储快照）。在EventSouring的时候，就不需要从Offset为0的地方开始回溯，就可以根据快照先恢复近期的数据状态，再从快照记录的Offset之后做回溯。</p>
<p>​一般情况下把<code>fileReservedTime=168</code>设置消息过期时间为7天即可。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="rocketmq的部署方案">RocketMQ的部署方案<a href="http://phoenix-website.sz.iquantex.com/blog/rocketmq-in-phoenix#rocketmq%E7%9A%84%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88" class="hash-link" aria-label="RocketMQ的部署方案的直接链接" title="RocketMQ的部署方案的直接链接">​</a></h3>
<p>​在Phoenix中，由于消息需要做到严格的有序且不丢，所以RocketMQ的部署方案，我们只能采用1master-1slave， 同步刷磁盘机制+同步写Slave节点模式。</p>
<p>​在1master-1slave场景下，RocketMQ是不能保证主备的自动切换的，所以目前主发生故障的时候，我们采用人工手动切换方式。</p>
<p>​在RocketMQ的Deleger版本中，提供了多副本的解决方案，可以做到自动选主，自动切换，正在探索是否是一个好的解决的方案。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="phoenix后续的roadmap">Phoenix后续的RoadMap<a href="http://phoenix-website.sz.iquantex.com/blog/rocketmq-in-phoenix#phoenix%E5%90%8E%E7%BB%AD%E7%9A%84roadmap" class="hash-link" aria-label="Phoenix后续的RoadMap的直接链接" title="Phoenix后续的RoadMap的直接链接">​</a></h2>
<ul>
<li>CServer主备切换</li>
<li>横向扩容支持</li>
<li>RocketMQ故障自动切换（基于Deleger方案）</li>
</ul>]]></content:encoded>
            <category>Phoenix</category>
            <category>Rocketmq</category>
        </item>
    </channel>
</rss>